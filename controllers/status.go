package controllers

/*
Copyright 2021-2025 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"regexp"
	"strings"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
	externaldns "sigs.k8s.io/external-dns/endpoint"
)

func (r *GslbReconciler) updateGslbStatus(gslb *k8gbv1beta1.Gslb, ep *externaldns.DNSEndpoint) error {

	m.UpdateIngressHostsPerStatusMetric(gslb, gslb.Status.ServiceHealth)

	var err error
	gslb.Status.HealthyRecords, err = r.getHealthyRecords(gslb)
	if err != nil {
		return err
	}

	gslb.Status.GeoTag = r.Config.ClusterGeoTag
	gslb.Status.Hosts = r.hostsToCSV(gslb)

	m.UpdateHealthyRecordsMetric(gslb, gslb.Status.HealthyRecords)

	m.UpdateEndpointStatus(ep)

	err = r.Status().Update(context.TODO(), gslb)
	return err
}

func (r *GslbReconciler) getServiceHealthStatus(gslb *k8gbv1beta1.Gslb) (map[string]k8gbv1beta1.HealthStatus, error) {
	serviceHealth := make(map[string]k8gbv1beta1.HealthStatus)
	for _, server := range gslb.Status.Servers {
		serviceHealth[server.Host] = k8gbv1beta1.NotFound
		for _, svc := range server.Services {
			service := &corev1.Service{}
			finder := client.ObjectKey{
				Namespace: svc.Namespace,
				Name:      svc.Name,
			}
			err := r.Get(context.TODO(), finder, service)
			if err != nil {
				if errors.IsNotFound(err) {
					continue
				}
				return serviceHealth, err
			}

			// If service is ExternalName, check if it points to another Kubernetes service
			if service.Spec.Type == corev1.ServiceTypeExternalName {
				// ExternalName services reference DNS names, which can be:
				// 1. Reference to internal K8s service: service.namespace.svc.cluster.local
				// 2. External DNS record: example.com

				// Check if it's a reference to a Kubernetes service
				if strings.Contains(service.Spec.ExternalName, ".svc") {
					// Try to extract service name and namespace from the ExternalName
					// Format is typically service.namespace.svc.cluster.local
					parts := strings.Split(service.Spec.ExternalName, ".")
					if len(parts) < 2 {
						// Malformed ExternalName - mark as NotFound
						serviceHealth[server.Host] = k8gbv1beta1.NotFound
						return serviceHealth, errors.NewBadRequest("Invalid ExternalName format")
					}

					serviceName := parts[0]
					serviceNamespace := parts[1]

					// Look up the referenced service
					referencedService := &corev1.Service{}
					referencedFinder := client.ObjectKey{
						Namespace: serviceNamespace,
						Name:      serviceName,
					}
					err := r.Get(context.TODO(), referencedFinder, referencedService)
					if err != nil {
						if errors.IsNotFound(err) {
							serviceHealth[server.Host] = k8gbv1beta1.NotFound
							return serviceHealth, err
						}
						serviceHealth[server.Host] = k8gbv1beta1.NotFound
						return serviceHealth, err
					}

					// Found the referenced service, check its endpoints
					health, err := r.checkServiceEndpoints(referencedService.Name, referencedService.Namespace)
					if err != nil {
						serviceHealth[server.Host] = k8gbv1beta1.NotFound
						return serviceHealth, err
					}
					serviceHealth[server.Host] = health
				} else {
					// External DNS record - mark as healthy
					serviceHealth[server.Host] = k8gbv1beta1.Healthy
				}
				continue
			}

			// For non-ExternalName services, check their endpoints directly
			health, err := r.checkServiceEndpoints(svc.Name, svc.Namespace)
			if err != nil {
				return serviceHealth, err
			}
			serviceHealth[server.Host] = health
		}
	}
	return serviceHealth, nil
}

func (r *GslbReconciler) checkServiceEndpoints(serviceName, namespace string) (k8gbv1beta1.HealthStatus, error) {
	endpoints := &corev1.Endpoints{}
	nn := types.NamespacedName{
		Name:      serviceName,
		Namespace: namespace,
	}
	err := r.Get(context.TODO(), nn, endpoints)
	if err != nil {
		return k8gbv1beta1.NotFound, err
	}

	if len(endpoints.Subsets) > 0 {
		for _, subset := range endpoints.Subsets {
			if len(subset.Addresses) > 0 {
				return k8gbv1beta1.Healthy, nil
			}
		}
	}
	return k8gbv1beta1.Unhealthy, nil
}

func (r *GslbReconciler) getHealthyRecords(gslb *k8gbv1beta1.Gslb) (map[string][]string, error) {

	dnsEndpoint := &externaldns.DNSEndpoint{}

	nn := types.NamespacedName{
		Name:      gslb.Name,
		Namespace: gslb.Namespace,
	}

	err := r.Get(context.TODO(), nn, dnsEndpoint)
	if err != nil {
		return nil, err
	}

	healthyRecords := make(map[string][]string)

	serviceRegex := regexp.MustCompile("^localtargets")
	for _, endpoint := range dnsEndpoint.Spec.Endpoints {
		local := serviceRegex.Match([]byte(endpoint.DNSName))
		if !local && endpoint.RecordType == "A" {
			if len(endpoint.Targets) > 0 {
				healthyRecords[endpoint.DNSName] = endpoint.Targets
			}
		}
	}

	return healthyRecords, nil
}

func (r *GslbReconciler) hostsToCSV(gslb *k8gbv1beta1.Gslb) string {
	var hosts []string
	for _, server := range gslb.Status.Servers {
		hosts = append(hosts, server.Host)
	}
	return strings.Join(hosts, ", ")
}
