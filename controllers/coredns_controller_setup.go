package controllers

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"fmt"

	"k8s.io/apimachinery/pkg/types"

	"github.com/k8gb-io/k8gb/controllers/logging"
	"github.com/k8gb-io/k8gb/controllers/providers/assistant"
	corev1 "k8s.io/api/core/v1"
	netv1 "k8s.io/api/networking/v1"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/handler"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
)

type ipSource struct {
	CoreDNSService *corev1.Service
	Ingress        *netv1.Ingress
	IPs            []string
}

var logger = logging.Logger()

func (r *CoreDNSReconciler) processIPSource(ctx context.Context, client client.Client) (*ipSource, error) {
	const coreDNSIngressRefAnnotation = "k8gb.io/coredns-ingress-ref"
	var err error
	source := &ipSource{}
	coreDNSAssistant := assistant.NewCoreDNSServiceAssistant(client, *r.Config)
	source.CoreDNSService, err = coreDNSAssistant.GetResource()
	if err != nil {
		return nil, err
	}
	if source.CoreDNSService.Spec.Type != corev1.ServiceTypeLoadBalancer {
		ingressPath, found := source.CoreDNSService.Annotations[coreDNSIngressRefAnnotation]
		if !found {
			return nil, fmt.Errorf("CoreDNS service does not have %s annotation", coreDNSIngressRefAnnotation)
		}
		ingressAssistant := assistant.NewIngressAssistant(ctx, client, ingressPath)
		source.Ingress, err = ingressAssistant.GetResource()
		if err != nil {
			return nil, err
		}
		source.IPs, err = ingressAssistant.GetExposedIPs()
		return source, err
	}
	// coreDNSService is ServiceTypeLoadBalancer
	source.IPs, err = coreDNSAssistant.GetExposedIPs()
	return source, err
}

func (r *CoreDNSReconciler) SetupWithManager(mgr ctrl.Manager) error {

	var coreDNSWatcher = handler.EnqueueRequestsFromMapFunc(
		func(_ context.Context, obj client.Object) []reconcile.Request {
			svc, _ := obj.(*corev1.Service)
			if svc.GetName() == r.source.CoreDNSService.Name && svc.GetNamespace() == r.source.CoreDNSService.Namespace {
				if r.source.Ingress == nil {
					return []reconcile.Request{{
						NamespacedName: types.NamespacedName{
							Namespace: svc.Namespace,
							Name:      svc.Name,
						},
					}}
				}
			}
			return nil
		})

	var ingressWatcher = handler.EnqueueRequestsFromMapFunc(
		func(_ context.Context, obj client.Object) []reconcile.Request {
			ing, _ := obj.(*netv1.Ingress)
			if r.source.Ingress == nil {
				return nil
			}
			if ing.GetName() == r.source.Ingress.Name && ing.GetNamespace() == r.source.Ingress.Namespace {
				return []reconcile.Request{{
					NamespacedName: types.NamespacedName{
						Namespace: ing.Namespace,
						Name:      ing.Name,
					},
				}}
			}
			return nil
		})

	uncachedClient, err := client.New(mgr.GetConfig(), client.Options{Scheme: r.Scheme})
	if err != nil {
		return fmt.Errorf("failed to create uncached client: %w", err)
	}
	source, err := r.processIPSource(context.TODO(), uncachedClient)
	if err != nil {
		return err
	}
	r.source = source

	return ctrl.NewControllerManagedBy(mgr).
		Named(source.CoreDNSService.Name).
		Watches(&corev1.Service{}, coreDNSWatcher).
		Watches(&netv1.Ingress{}, ingressWatcher).
		Complete(r)
}
