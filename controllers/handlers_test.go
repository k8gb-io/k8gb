package controllers

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"testing"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	"github.com/k8gb-io/k8gb/controllers/mocks"
	"github.com/k8gb-io/k8gb/controllers/refresolver/ingress"
	"github.com/k8gb-io/k8gb/controllers/utils"
	"github.com/stretchr/testify/assert"
	"go.uber.org/mock/gomock"
	netv1 "k8s.io/api/networking/v1"
	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	clientgoscheme "k8s.io/client-go/kubernetes/scheme"
)

func TestIngressHandler(t *testing.T) {
	const dummy = "default"
	var spec = netv1.IngressSpec{
		IngressClassName: utils.Ptr("nginx"),
		Rules: []netv1.IngressRule{
			{
				Host: "app.claud.example.com",
				IngressRuleValue: netv1.IngressRuleValue{
					HTTP: &netv1.HTTPIngressRuleValue{
						Paths: []netv1.HTTPIngressPath{
							{
								Path:     "/",
								PathType: (*netv1.PathType)(utils.Ptr("Prefix")),
								Backend: netv1.IngressBackend{
									Service: &netv1.IngressServiceBackend{
										Name: dummy,
										Port: netv1.ServiceBackendPort{
											Name:   "http",
											Number: 8080,
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}

	var tests = []struct {
		name      string
		ing       *netv1.Ingress
		getClient func(*gomock.Controller) *mocks.MockClient
	}{
		{
			name: "Ingress has not k8gb annotation",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:        dummy,
					Namespace:   dummy,
					Annotations: map[string]string{dummy: dummy},
				},
				Spec: spec,
			},
			getClient: mocks.NewMockClient,
		},
		{
			name: "Ingress is owned by GSLB",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:        dummy,
					Namespace:   dummy,
					Annotations: map[string]string{dummy: dummy, strategyAnnotation: "roundRobin"},
					OwnerReferences: []metav1.OwnerReference{
						{
							Name: dummy,
							Kind: "Gslb",
						},
					},
				},
				Spec: spec,
			},
			getClient: mocks.NewMockClient,
		},
		{
			name: "Create new RoundRobin Ingress with ExternalIPsAnnotation already exists (IPs from Ingress)",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:      dummy,
					Namespace: dummy,
					Annotations: map[string]string{
						ingress.ExternalIPsAnnotation: "10.0.0.1",
						strategyAnnotation:            "roundRobin"},
				},
				Spec: spec,
			},
			getClient: func(ctrl *gomock.Controller) *mocks.MockClient {
				cl := mocks.NewMockClient(ctrl)
				// ingress to reuse
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				// existing gslb - doesnt exists
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(k8serrors.NewNotFound(schema.GroupResource{Group: "k8gb.absa.oss/v1beta1", Resource: "Gslb"}, dummy)).
					Times(1)
				// create gslb
				cl.EXPECT().Create(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				return cl
			},
		},
		{
			name: "Create new RoundRobin Ingress WITHOUT ExternalIPsAnnotation already exists (IPs from LoadBalancer)",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:      dummy,
					Namespace: dummy,
					Annotations: map[string]string{
						strategyAnnotation: "roundRobin",
					},
				},
				Spec: spec,
			},
			getClient: func(ctrl *gomock.Controller) *mocks.MockClient {
				cl := mocks.NewMockClient(ctrl)
				// ingress to reuse
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				// existing gslb - doesnt exists
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(k8serrors.NewNotFound(schema.GroupResource{Group: "k8gb.absa.oss/v1beta1", Resource: "Gslb"}, dummy)).
					Times(1)
				// create gslb
				cl.EXPECT().Create(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				return cl
			},
		},

		{
			name: "Update existing RoundRobin Ingress with ExternalIPsAnnotation already exists (IPs from Ingress)",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:      dummy,
					Namespace: dummy,
					Annotations: map[string]string{
						ingress.ExternalIPsAnnotation: "10.0.0.1",
						strategyAnnotation:            "roundRobin"},
				},
				Spec: spec,
			},
			getClient: func(ctrl *gomock.Controller) *mocks.MockClient {
				cl := mocks.NewMockClient(ctrl)
				// ingress to reuse
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				// existing gslb - doesnt exists
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(nil).
					Times(1)
				// create gslb
				cl.EXPECT().Update(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				return cl
			},
		},

		{
			name: "Update existing RoundRobin Ingress WITHOUT ExternalIPsAnnotation already exists (IPs from LoadBalancer)",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:      dummy,
					Namespace: dummy,
					Annotations: map[string]string{
						strategyAnnotation: "roundRobin"},
				},
				Spec: spec,
			},
			getClient: func(ctrl *gomock.Controller) *mocks.MockClient {
				cl := mocks.NewMockClient(ctrl)
				// ingress to reuse
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				// existing gslb - doesnt exists
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(nil).
					Times(1)
				// create gslb
				cl.EXPECT().Update(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				return cl
			},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {

			// arrange
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			client := test.getClient(ctrl)
			scheme := runtime.NewScheme()
			utilruntime.Must(clientgoscheme.AddToScheme(scheme))
			utilruntime.Must(netv1.AddToScheme(scheme))
			utilruntime.Must(k8gbv1beta1.AddToScheme(scheme))
			handler := NewIngressHandler(context.TODO(), client, scheme)

			// act
			result := handler.Handle(test.ing)

			// assert
			assert.Nil(t, result)
		})
	}
}
