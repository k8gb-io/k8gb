package controllers

/*
Copyright 2021-2025 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"testing"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	"github.com/k8gb-io/k8gb/controllers/mocks"
	"github.com/k8gb-io/k8gb/controllers/refresolver/ingress"
	"github.com/k8gb-io/k8gb/controllers/utils"
	"github.com/stretchr/testify/assert"
	"go.uber.org/mock/gomock"
	corev1 "k8s.io/api/core/v1"
	netv1 "k8s.io/api/networking/v1"
	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	clientgoscheme "k8s.io/client-go/kubernetes/scheme"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
)

func TestIngressHandler(t *testing.T) {
	const dummy = "default"
	var spec = netv1.IngressSpec{
		IngressClassName: utils.Ptr("nginx"),
		Rules: []netv1.IngressRule{
			{
				Host: "app.claud.example.com",
				IngressRuleValue: netv1.IngressRuleValue{
					HTTP: &netv1.HTTPIngressRuleValue{
						Paths: []netv1.HTTPIngressPath{
							{
								Path:     "/",
								PathType: (*netv1.PathType)(utils.Ptr("Prefix")),
								Backend: netv1.IngressBackend{
									Service: &netv1.IngressServiceBackend{
										Name: dummy,
										Port: netv1.ServiceBackendPort{
											Name:   "http",
											Number: 8080,
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}

	var tests = []struct {
		name      string
		ing       *netv1.Ingress
		getClient func(*gomock.Controller) *mocks.MockClient
	}{
		{
			name: "Ingress has not k8gb annotation",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:        dummy,
					Namespace:   dummy,
					Annotations: map[string]string{dummy: dummy},
				},
				Spec: spec,
			},
			getClient: mocks.NewMockClient,
		},
		{
			name: "Ingress is owned by GSLB",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:        dummy,
					Namespace:   dummy,
					Annotations: map[string]string{dummy: dummy, strategyAnnotation: "roundRobin"},
					OwnerReferences: []metav1.OwnerReference{
						{
							Name: dummy,
							Kind: "Gslb",
						},
					},
				},
				Spec: spec,
			},
			getClient: mocks.NewMockClient,
		},
		{
			name: "Create new RoundRobin Ingress with ExternalIPsAnnotation already exists (IPs from Ingress)",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:      dummy,
					Namespace: dummy,
					Annotations: map[string]string{
						ingress.ExternalIPsAnnotation: "10.0.0.1",
						strategyAnnotation:            "roundRobin"},
				},
				Spec: spec,
			},
			getClient: func(ctrl *gomock.Controller) *mocks.MockClient {
				cl := mocks.NewMockClient(ctrl)
				// ingress to reuse
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				// existing gslb - doesnt exists
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(k8serrors.NewNotFound(schema.GroupResource{Group: "k8gb.absa.oss/v1beta1", Resource: "Gslb"}, dummy)).
					Times(1)
				// create gslb
				cl.EXPECT().Create(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				return cl
			},
		},
		{
			name: "Create new RoundRobin Ingress WITHOUT ExternalIPsAnnotation already exists (IPs from LoadBalancer)",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:      dummy,
					Namespace: dummy,
					Annotations: map[string]string{
						strategyAnnotation: "roundRobin",
					},
				},
				Spec: spec,
			},
			getClient: func(ctrl *gomock.Controller) *mocks.MockClient {
				cl := mocks.NewMockClient(ctrl)
				// ingress to reuse
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				// existing gslb - doesnt exists
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(k8serrors.NewNotFound(schema.GroupResource{Group: "k8gb.absa.oss/v1beta1", Resource: "Gslb"}, dummy)).
					Times(1)
				// create gslb
				cl.EXPECT().Create(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				return cl
			},
		},

		{
			name: "Update existing RoundRobin Ingress with ExternalIPsAnnotation already exists (IPs from Ingress)",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:      dummy,
					Namespace: dummy,
					Annotations: map[string]string{
						ingress.ExternalIPsAnnotation: "10.0.0.1",
						strategyAnnotation:            "roundRobin"},
				},
				Spec: spec,
			},
			getClient: func(ctrl *gomock.Controller) *mocks.MockClient {
				cl := mocks.NewMockClient(ctrl)
				// ingress to reuse
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				// existing gslb - doesnt exists
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(nil).
					Times(1)
				// create gslb
				cl.EXPECT().Update(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				return cl
			},
		},

		{
			name: "Update existing RoundRobin Ingress WITHOUT ExternalIPsAnnotation already exists (IPs from LoadBalancer)",
			ing: &netv1.Ingress{
				ObjectMeta: metav1.ObjectMeta{
					Name:      dummy,
					Namespace: dummy,
					Annotations: map[string]string{
						strategyAnnotation: "roundRobin"},
				},
				Spec: spec,
			},
			getClient: func(ctrl *gomock.Controller) *mocks.MockClient {
				cl := mocks.NewMockClient(ctrl)
				// ingress to reuse
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				// existing gslb - doesnt exists
				cl.EXPECT().Get(gomock.Any(), gomock.Any(), gomock.Any()).
					Return(nil).
					Times(1)
				// create gslb
				cl.EXPECT().Update(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil).Times(1)
				return cl
			},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {

			// arrange
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			client := test.getClient(ctrl)
			scheme := runtime.NewScheme()
			utilruntime.Must(clientgoscheme.AddToScheme(scheme))
			utilruntime.Must(netv1.AddToScheme(scheme))
			utilruntime.Must(k8gbv1beta1.AddToScheme(scheme))
			handler := NewIngressHandler(context.TODO(), client, scheme)

			// act
			result := handler.Handle(test.ing)

			// assert
			assert.Nil(t, result)
		})
	}
}

func TestServiceHandler(t *testing.T) {
	// Create a test scheme
	scheme := runtime.NewScheme()
	_ = corev1.AddToScheme(scheme)
	_ = k8gbv1beta1.AddToScheme(scheme)

	// Create a test client
	client := fake.NewClientBuilder().WithScheme(scheme).Build()

	// Create a ServiceHandler
	handler := NewServiceHandler(context.TODO(), client, scheme)

	// Test 1: Service without k8gb annotations should not trigger GSLB creation
	serviceWithoutAnnotations := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-service",
			Namespace: "default",
		},
		Spec: corev1.ServiceSpec{
			Type: corev1.ServiceTypeLoadBalancer,
		},
	}

	requests := handler.Handle(serviceWithoutAnnotations)
	assert.Empty(t, requests, "Service without k8gb annotations should not trigger reconciliation")

	// Test 2: Service with strategy annotation but not LoadBalancer type should not trigger GSLB creation
	serviceNotLoadBalancer := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-service",
			Namespace: "default",
			Annotations: map[string]string{
				"k8gb.io/strategy": "roundRobin",
			},
		},
		Spec: corev1.ServiceSpec{
			Type: corev1.ServiceTypeClusterIP,
		},
	}

	requests = handler.Handle(serviceNotLoadBalancer)
	assert.Empty(t, requests, "Service that is not LoadBalancer type should not trigger reconciliation")

	// Test 3: Service with strategy annotation but without hostname should not trigger GSLB creation
	serviceWithoutHostname := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-service",
			Namespace: "default",
			Annotations: map[string]string{
				"k8gb.io/strategy": "roundRobin",
			},
		},
		Spec: corev1.ServiceSpec{
			Type: corev1.ServiceTypeLoadBalancer,
		},
	}

	requests = handler.Handle(serviceWithoutHostname)
	assert.Empty(t, requests, "Service without hostname annotation should not trigger reconciliation")

	// Test 4: Valid LoadBalancer service with all required annotations should trigger GSLB creation
	validService := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-service",
			Namespace: "default",
			Annotations: map[string]string{
				"k8gb.io/strategy": "roundRobin",
				"k8gb.io/hostname": "test.example.com",
			},
		},
		Spec: corev1.ServiceSpec{
			Type: corev1.ServiceTypeLoadBalancer,
		},
	}

	// Add the service to the client
	err := client.Create(context.TODO(), validService)
	assert.NoError(t, err)

	requests = handler.Handle(validService)
	assert.Empty(t, requests, "Valid service should trigger GSLB creation but return empty requests")

	// Verify that GSLB was created
	gslb := &k8gbv1beta1.Gslb{}
	err = client.Get(context.TODO(), types.NamespacedName{Name: "test-service", Namespace: "default"}, gslb)
	assert.NoError(t, err, "GSLB should be created")
	assert.Equal(t, "test-service", gslb.Name)
	assert.Equal(t, "default", gslb.Namespace)
	assert.Equal(t, "Service", gslb.Spec.ResourceRef.Kind)
	assert.Equal(t, "v1", gslb.Spec.ResourceRef.APIVersion)
	assert.Equal(t, "test-service", gslb.Spec.ResourceRef.Name)
	assert.Equal(t, "roundRobin", gslb.Spec.Strategy.Type)
	assert.Equal(t, "test.example.com", gslb.Annotations["k8gb.io/hostname"])

	// Test 5: Service owned by GSLB should not trigger new GSLB creation
	ownedService := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "owned-service",
			Namespace: "default",
			Annotations: map[string]string{
				"k8gb.io/strategy": "roundRobin",
				"k8gb.io/hostname": "owned.example.com",
			},
			OwnerReferences: []metav1.OwnerReference{
				{
					Kind: "Gslb",
					Name: "existing-gslb",
				},
			},
		},
		Spec: corev1.ServiceSpec{
			Type: corev1.ServiceTypeLoadBalancer,
		},
	}

	requests = handler.Handle(ownedService)
	assert.Empty(t, requests, "Service owned by GSLB should not trigger new GSLB creation")
}
