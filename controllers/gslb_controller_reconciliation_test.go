package controllers

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"fmt"
	"net"
	"os"
	"sort"
	"strings"
	"testing"
	"time"

	"sigs.k8s.io/controller-runtime/pkg/client/fake"

	utils "github.com/k8gb-io/k8gb/controllers/utils"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	"github.com/k8gb-io/k8gb/controllers/depresolver"
	"github.com/k8gb-io/k8gb/controllers/logging"
	"github.com/k8gb-io/k8gb/controllers/mocks"
	"github.com/k8gb-io/k8gb/controllers/providers/assistant"
	"github.com/k8gb-io/k8gb/controllers/providers/dns"
	"github.com/k8gb-io/k8gb/controllers/providers/metrics"
	"github.com/k8gb-io/k8gb/controllers/tracing"

	str "github.com/AbsaOSS/gopkg/string"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/mock/gomock"
	corev1 "k8s.io/api/core/v1"
	netv1 "k8s.io/api/networking/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes/scheme"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
	externaldns "sigs.k8s.io/external-dns/endpoint"
)

type testSettings struct {
	gslb       *k8gbv1beta1.Gslb
	reconciler *GslbReconciler
	request    reconcile.Request
	config     depresolver.Config
	client     client.Client
	ingress    *netv1.Ingress
	finalCall  bool
	assistant  assistant.Assistant
}

var crSampleYaml = "../deploy/crds/k8gb.absa.oss_v1beta1_gslb_cr_roundrobin_ingress.yaml"

var predefinedConfig = depresolver.Config{
	ReconcileRequeueSeconds: 30,
	ClusterGeoTag:           "us-west-1",
	ExtClustersGeoTags:      []string{"us-east-1"},
	EdgeDNSServers: []utils.DNSServer{
		{
			Host: "127.0.0.1",
			Port: 7753,
		},
	},
	EdgeDNSZone:   "example.com",
	DNSZone:       "cloud.example.com",
	K8gbNamespace: "k8gb",
	Infoblox: depresolver.Infoblox{
		Host:                "fakeinfoblox.example.com",
		Username:            "foo",
		Password:            "blah",
		Port:                443,
		Version:             "0.0.0",
		HTTPPoolConnections: 20,
		HTTPRequestTimeout:  10,
	},
	Log: depresolver.Log{
		Format: depresolver.SimpleFormat,
	},
}

var fakeDNSSettings = utils.FakeDNSSettings{
	FakeDNSPort:     7753,
	EdgeDNSZoneFQDN: "example.com.",
	DNSZoneFQDN:     "cloud.example.com.",
}

const (
	defaultCoreDNSExtServiceName = "k8gb-coredns-randomname"
	defaultUnhealthyServiceName  = "unhealthy-app"
	defaultPodinfoServiceName    = "frontend-podinfo"
	defaultEdgeDNS0              = "1.0.0.1"
	defaultEdgeDNS1              = "1.1.1.1"
)

var defaultEdgeDNSServers = []utils.DNSServer{
	{
		Host: defaultEdgeDNS1,
		Port: 53,
	},
}

func TestNotFoundServiceStatus(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			settings := provideSettings(t, predefinedConfig)
			expectedServiceStatus := k8gbv1beta1.NotFound
			notFoundHost := "notfound.cloud.example.com"
			// act
			actualServiceStatus := settings.gslb.Status.ServiceHealth[notFoundHost]
			// assert
			assert.Equal(t, expectedServiceStatus, actualServiceStatus, "expected %s service status to be %s, but got %s",
				notFoundHost, expectedServiceStatus, actualServiceStatus)
		})
}

func TestUnhealthyServiceStatus(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			settings := provideSettings(t, predefinedConfig)
			serviceName := defaultUnhealthyServiceName
			unhealthyHost := "unhealthy.cloud.example.com"
			expectedServiceStatus := k8gbv1beta1.Unhealthy
			defer deleteUnhealthyService(t, &settings, serviceName)
			// act
			createUnhealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			// assert
			actualServiceStatus := settings.gslb.Status.ServiceHealth[unhealthyHost]
			assert.Equal(t, expectedServiceStatus, actualServiceStatus, "expected %s service status to be %s, but got %s",
				unhealthyHost, expectedServiceStatus, actualServiceStatus)
		})
}

func TestHealthyServiceStatus(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			settings := provideSettings(t, predefinedConfig)
			serviceName := defaultPodinfoServiceName
			expectedServiceStatus := k8gbv1beta1.Healthy
			healthyHost := "roundrobin.cloud.example.com"
			defer deleteHealthyService(t, &settings, serviceName)
			createHealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			// act
			actualServiceStatus := settings.gslb.Status.ServiceHealth[healthyHost]
			// assert
			assert.Equal(t, expectedServiceStatus, actualServiceStatus, "expected %s service status to be %s, but got %s",
				healthyHost, expectedServiceStatus, actualServiceStatus)
		})
}

func TestHostsInStatusAreAdded(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			settings := provideSettings(t, predefinedConfig)
			settings.gslb.Status.Hosts = ""
			hostsInStatusBeforeReconciliation := settings.gslb.Status.Hosts
			expectedHostsInStatus := settings.reconciler.hostsToCSV(settings.gslb)

			reconcileAndUpdateGslb(t, settings)
			// act
			actualHostsInStatus := settings.gslb.Status.Hosts

			// assert
			assert.Empty(t, hostsInStatusBeforeReconciliation, "for gslb: '%s', the '.status.hosts' should be empty before reconciliation, but was: '%s'",
				settings.gslb.Name, hostsInStatusBeforeReconciliation)
			assert.NotEmpty(t, actualHostsInStatus, "for gslb: '%s', expected status.hosts to be not empty", settings.gslb.Name)
			assert.Equal(t, expectedHostsInStatus, actualHostsInStatus)
		})
}

func TestHostsInStatusAllPresent(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			settings := provideSettings(t, predefinedConfig)
			var expectedHosts []string
			for _, h := range settings.gslb.Spec.Ingress.Rules {
				expectedHosts = append(expectedHosts, h.Host)
			}

			reconcileAndUpdateGslb(t, settings)
			// act
			actualHostsInStatus := settings.reconciler.hostsToCSV(settings.gslb)

			// assert
			for _, expectedHost := range expectedHosts {
				assert.Contains(t, actualHostsInStatus, expectedHost, "for gslb: %s, expecting %s to be present in status.hosts (%s)",
					settings.gslb.Name, expectedHost, actualHostsInStatus)
			}
		})
}

func TestIngressHostsPerStatusMetric(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			settings := provideSettings(t, predefinedConfig)
			expectedHostsMetricCount := 3
			// act
			ingressHostsPerStatusMetric := metrics.Metrics().Get(metrics.K8gbGslbServiceStatusNum).AsGaugeVec()
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.gslb)
			actualHostsMetricCount := testutil.CollectAndCount(ingressHostsPerStatusMetric)
			// assert
			assert.NoError(t, err, "Failed to get expected gslb")
			assert.Equal(t, expectedHostsMetricCount, actualHostsMetricCount, "expected %v managed hosts, but got %v",
				expectedHostsMetricCount, actualHostsMetricCount)
		})
}

func TestIngressHostsPerStatusMetricReflectionForHealthyStatus(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// I'm running test multiple times to check that it work properly when healthy service is up and down multiple times
			for i := 0; i < 4; i++ {
				func() {
					// arrange
					settings := provideSettings(t, predefinedConfig)
					serviceName := defaultPodinfoServiceName
					defer deleteHealthyService(t, &settings, serviceName)
					expectedHostsMetric := 1.
					createHealthyService(t, &settings, serviceName)
					reconcileAndUpdateGslb(t, settings)
					// act
					err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.gslb)
					ingressHostsPerStatusMetric := metrics.Metrics().Get(metrics.K8gbGslbServiceStatusNum).AsGaugeVec()
					healthyHosts := ingressHostsPerStatusMetric.With(prometheus.Labels{"namespace": settings.gslb.Namespace,
						"name": settings.gslb.Name, "status": k8gbv1beta1.Healthy.String()})
					actualHostsMetric := testutil.ToFloat64(healthyHosts)
					// assert
					assert.NoError(t, err, "Failed to get expected gslb")
					assert.Equal(t, expectedHostsMetric, actualHostsMetric, "expected %v managed hosts with Healthy status, but got %v",
						expectedHostsMetric, actualHostsMetric)
				}()
			}
		})
}

func TestIngressHostsPerStatusMetricReflectionForUnhealthyStatus(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			settings := provideSettings(t, predefinedConfig)
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.gslb)
			expectedHostsMetricCount := 0.
			// act
			ingressHostsPerStatusMetric := metrics.Metrics().Get(metrics.K8gbGslbServiceStatusNum).AsGaugeVec()
			unhealthyHosts := ingressHostsPerStatusMetric.With(prometheus.Labels{"namespace": settings.gslb.Namespace,
				"name": settings.gslb.Name, "status": k8gbv1beta1.Unhealthy.String()})
			actualHostsMetricCount := testutil.ToFloat64(unhealthyHosts)
			// assert
			assert.NoError(t, err, "Failed to get expected gslb")
			assert.Equal(t, expectedHostsMetricCount, actualHostsMetricCount, "expected %v managed hosts, but got %v",
				expectedHostsMetricCount, actualHostsMetricCount)

			// arrange
			serviceName := defaultUnhealthyServiceName
			createUnhealthyService(t, &settings, serviceName)
			defer deleteUnhealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			expectedHostsMetricCount = 1
			// act
			unhealthyHosts =
				ingressHostsPerStatusMetric.With(prometheus.Labels{"namespace": settings.gslb.Namespace,
					"name": settings.gslb.Name, "status": k8gbv1beta1.Unhealthy.String()})
			actualHostsMetricCount = testutil.ToFloat64(unhealthyHosts)
			// assert
			assert.Equal(t, expectedHostsMetricCount, actualHostsMetricCount, "expected %v managed hosts with Healthy status, but got %v",
				expectedHostsMetricCount, actualHostsMetricCount)
		})
}

func TestIngressHostsPerStatusMetricReflectionForNotFoundStatus(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			settings := provideSettings(t, predefinedConfig)
			expectedHostsMetricCount := 2.0

			serviceName := defaultUnhealthyServiceName
			createUnhealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			deleteUnhealthyService(t, &settings, serviceName)

			// act
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.gslb)
			require.NoError(t, err, "Failed to get expected gslb")
			ingressHostsPerStatusMetric := metrics.Metrics().Get(metrics.K8gbGslbServiceStatusNum).AsGaugeVec()
			unknownHosts, err := ingressHostsPerStatusMetric.GetMetricWith(
				prometheus.Labels{"namespace": settings.gslb.Namespace, "name": settings.gslb.Name, "status": k8gbv1beta1.NotFound.String()})
			require.NoError(t, err, "Failed to get ingress metrics")
			actualHostsMetricCount := testutil.ToFloat64(unknownHosts)
			// assert
			assert.Equal(t, expectedHostsMetricCount, actualHostsMetricCount, "expected %v managed hosts with NotFound status, but got %v",
				expectedHostsMetricCount, actualHostsMetricCount)
		})
}

func TestHealthyRecordMetric(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			expectedHealthyRecordsMetricCount := 3.0
			ingressIPs := []netv1.IngressLoadBalancerIngress{
				{IP: "10.0.0.1"},
				{IP: "10.0.0.2"},
				{IP: "10.0.0.3"},
			}
			serviceName := defaultPodinfoServiceName
			settings := provideSettings(t, predefinedConfig)
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.gslb)
			require.NoError(t, err, "Failed to get expected gslb")
			defer deleteHealthyService(t, &settings, serviceName)
			createHealthyService(t, &settings, serviceName)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")
			reconcileAndUpdateGslb(t, settings)
			// act
			healthyRecordsMetric := metrics.Metrics().Get(metrics.K8gbGslbHealthyRecords).AsGaugeVec()
			actualHealthyRecordsMetricCount := testutil.ToFloat64(healthyRecordsMetric)
			reconcileAndUpdateGslb(t, settings)
			// assert
			assert.Equal(t, expectedHealthyRecordsMetricCount, actualHealthyRecordsMetricCount, "expected %v healthy records, but got %v",
				expectedHealthyRecordsMetricCount, actualHealthyRecordsMetricCount)
		})
}

func TestGslbReconciliationTotalIncrement(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 3)).
		Start().
		RunTestFunc(func() {
			// arrange
			settings := provideSettings(t, predefinedConfig)
			cnt := testutil.ToFloat64(metrics.Metrics().Get(metrics.K8gbGslbReconciliationLoopsTotal).AsCounterVec())
			// act
			_, err := settings.reconciler.Reconcile(context.TODO(), settings.request)
			cnt2 := testutil.ToFloat64(metrics.Metrics().Get(metrics.K8gbGslbReconciliationLoopsTotal).AsCounterVec())
			// assert
			assert.NoError(t, err)
			assert.Equal(t, cnt+1, cnt2)
		})
}

func TestGslbErrorsIncrement(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 3)).
		Start().
		RunTestFunc(func() {
			// arrange
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			settings := provideSettings(t, predefinedConfig)
			var label = prometheus.Labels{"namespace": settings.gslb.Namespace, "name": settings.gslb.Name}
			m := mocks.NewMockProvider(ctrl)
			cnt := testutil.ToFloat64(metrics.Metrics().Get(metrics.K8gbGslbErrorsTotal).AsCounterVec().With(label))
			m.EXPECT().SaveDNSEndpoint(gomock.Any(), gomock.Any()).Return(fmt.Errorf("save DNS error")).Times(1)
			m.EXPECT().GetExternalTargets(gomock.Any()).Return(assistant.Targets{}).AnyTimes()
			settings.reconciler.DNSProvider = m
			// act
			_, err := settings.reconciler.Reconcile(context.TODO(), settings.request)
			require.Error(t, err)
			// let's break it on different place
			m.EXPECT().SaveDNSEndpoint(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()
			m.EXPECT().CreateZoneDelegationForExternalDNS(gomock.Any()).Return(fmt.Errorf("zone delegation error")).AnyTimes()
			_, err = settings.reconciler.Reconcile(context.TODO(), settings.request)
			cnt2 := testutil.ToFloat64(metrics.Metrics().Get(metrics.K8gbGslbErrorsTotal).AsCounterVec().With(label))
			// assert
			assert.NoError(t, err)
			assert.Equal(t, cnt+2, cnt2)
		})
}

func TestGslbCreatesDNSEndpointCRForHealthyIngressHosts(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			serviceName := defaultPodinfoServiceName
			dnsEndpoint := &externaldns.DNSEndpoint{}
			want := []*externaldns.Endpoint{
				{
					DNSName:    "localtargets-roundrobin.cloud.example.com",
					RecordTTL:  30,
					RecordType: "A",
					Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"}},
				{
					DNSName:    "roundrobin.cloud.example.com",
					RecordTTL:  30,
					RecordType: "A",
					Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"},
					Labels:     externaldns.Labels{"strategy": "roundRobin"}},
			}
			ingressIPs := []netv1.IngressLoadBalancerIngress{
				{IP: "10.0.0.1"},
				{IP: "10.0.0.2"},
				{IP: "10.0.0.3"},
			}
			settings := provideSettings(t, predefinedConfig)
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")
			createHealthyService(t, &settings, serviceName)
			defer deleteHealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)

			// act
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to load DNS endpoint")
			got := dnsEndpoint.Spec.Endpoints
			prettyGot := str.ToString(got)
			prettyWant := str.ToString(want)

			// assert
			assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
		})
}

func TestDNSRecordReflectionInStatus(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			serviceName := defaultPodinfoServiceName
			dnsEndpoint := &externaldns.DNSEndpoint{}
			want := map[string][]string{"roundrobin.cloud.example.com": {"10.0.0.1", "10.0.0.2", "10.0.0.3"}}
			ingressIPs := []netv1.IngressLoadBalancerIngress{
				{IP: "10.0.0.1"},
				{IP: "10.0.0.2"},
				{IP: "10.0.0.3"},
			}
			settings := provideSettings(t, predefinedConfig)
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")

			// act
			createHealthyService(t, &settings, serviceName)
			defer deleteHealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to load DNS endpoint")
			got := settings.gslb.Status.HealthyRecords

			// assert
			assert.Equal(t, got, want, "got:\n %s healthyRecordsMetric status,\n\n want:\n %s", got, want)
		})
}

func TestLocalDNSRecordsHasSpecialAnnotation(t *testing.T) {
	// arrange
	serviceName := defaultPodinfoServiceName
	dnsEndpoint := &externaldns.DNSEndpoint{}
	want := "local"
	ingressIPs := []netv1.IngressLoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
		{IP: "10.0.0.3"},
	}
	utils.NewFakeDNS(fakeDNSSettings).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 3)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 2)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 1)).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, predefinedConfig)
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")

			// act
			createHealthyService(t, &settings, serviceName)
			// delete DNSEndpoint so we can pretend it wasn't annotated before
			deleteDNSEndpoint(t, &settings)
			createDNSEndpoint(t, &settings)
			defer deleteHealthyService(t, &settings, serviceName)
			defer deleteDNSEndpoint(t, &settings)
			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to load DNS endpoint")
			got := dnsEndpoint.Annotations["k8gb.absa.oss/dnstype"]

			// assert
			assert.Equal(t, want, got, "got:\n %q annotation value,\n\n want:\n %q", got, want)
		}).RequireNoError(t)
}

func TestCanGetExternalTargetsFromK8gbInAnotherLocation(t *testing.T) {
	// arrange
	serviceName := defaultPodinfoServiceName
	want := []*externaldns.Endpoint{
		{
			DNSName:    "localtargets-roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"}},
		{
			DNSName:    "roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3", "10.1.0.1", "10.1.0.2", "10.1.0.3"},
			Labels:     externaldns.Labels{"strategy": "roundRobin"}},
	}
	hrWant := map[string][]string{"roundrobin.cloud.example.com": {"10.0.0.1", "10.0.0.2", "10.0.0.3", "10.1.0.1", "10.1.0.2", "10.1.0.3"}}
	ingressIPs := []netv1.IngressLoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
		{IP: "10.0.0.3"},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	utils.NewFakeDNS(fakeDNSSettings).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 3)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 2)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 1)).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, predefinedConfig)

			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")

			// act
			createHealthyService(t, &settings, serviceName)
			defer deleteHealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to get expected DNSEndpoint")

			got := dnsEndpoint.Spec.Endpoints
			hrGot := settings.gslb.Status.HealthyRecords

			sort.Strings(got[0].Targets)
			sort.Strings(want[0].Targets)
			sort.Strings(got[1].Targets)
			sort.Strings(want[1].Targets)
			prettyGot := str.ToString(got)
			prettyWant := str.ToString(want)

			// assert
			assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
			sort.Strings(hrGot["roundrobin.cloud.example.com"])
			sort.Strings(hrWant["roundrobin.cloud.example.com"])
			assert.Equal(t, hrGot, hrWant, "got:\n %s Gslb Records status,\n\n want:\n %s", hrGot, hrWant)
		}).RequireNoError(t)
}

func TestCanCheckExternalGslbTXTRecordForValidityAndFailIfItIsExpired(t *testing.T) {
	// arrange
	utils.NewFakeDNS(fakeDNSSettings).
		AddTXTRecord("test-gslb-heartbeat-eu.example.com.", oldEdgeTimestamp("10m")).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, predefinedConfig)
			// act
			got := settings.assistant.InspectTXTThreshold("test-gslb-heartbeat-eu.example.com", time.Minute*5)
			want := errors.NewResourceExpired("Split brain TXT record expired the time threshold: (5m0s)")
			// assert
			assert.Equal(t, want, got, "got:\n %s from TXT split brain check,\n\n want error:\n %v", got, want)
		}).RequireNoError(t)
}

func TestCanCheckExternalGslbTXTRecordForValidityAndPAssIfItISNotExpired(t *testing.T) {
	// arrange
	utils.NewFakeDNS(fakeDNSSettings).
		AddTXTRecord("test-gslb-heartbeat-za.example.com.", oldEdgeTimestamp("3m")).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, predefinedConfig)
			// act
			err2 := settings.assistant.InspectTXTThreshold("test-gslb-heartbeat-za.example.com", time.Minute*5)
			// assert
			assert.NoError(t, err2, "got:\n %s from TXT split brain check,\n\n want error:\n %v", err2, nil)
		}).RequireNoError(t)
}

func TestReturnsOwnRecordsUsingFailoverStrategyWhenPrimary(t *testing.T) {
	serviceName := defaultPodinfoServiceName
	want := []*externaldns.Endpoint{
		{
			DNSName:    "localtargets-roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"},
		},
		{
			DNSName:    "roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"},
			Labels:     externaldns.Labels{"strategy": depresolver.FailoverStrategy},
		},
	}
	ingressIPs := []netv1.IngressLoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
		{IP: "10.0.0.3"},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	customConfig := predefinedConfig
	customConfig.ClusterGeoTag = "eu"
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, customConfig)

			// ingress
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")

			// enable failover strategy
			settings.gslb.Spec.Strategy.Type = depresolver.FailoverStrategy
			settings.gslb.Spec.Strategy.PrimaryGeoTag = "eu"
			err = settings.client.Update(context.TODO(), settings.gslb)
			require.NoError(t, err, "Can't update gslb")

			// act
			createHealthyService(t, &settings, serviceName)
			defer deleteHealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to get expected DNSEndpoint")
			got := dnsEndpoint.Spec.Endpoints
			prettyGot := str.ToString(got)
			prettyWant := str.ToString(want)

			// assert
			assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
		})
}

func TestReturnsExternalRecordsUsingFailoverStrategy(t *testing.T) {
	// arrange
	serviceName := defaultPodinfoServiceName
	want := []*externaldns.Endpoint{
		{
			DNSName:    "localtargets-roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"},
		},
		{
			DNSName:    "roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.1.0.1", "10.1.0.2", "10.1.0.3"},
			Labels:     externaldns.Labels{"strategy": depresolver.FailoverStrategy},
		},
	}
	ingressIPs := []netv1.IngressLoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
		{IP: "10.0.0.3"},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	customConfig := predefinedConfig
	customConfig.EdgeDNSServers = []utils.DNSServer{
		{
			Host: "localhost",
			Port: 7753,
		},
	}
	utils.NewFakeDNS(fakeDNSSettings).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 3)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 2)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 1)).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, customConfig)

			// ingress
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")

			// enable failover strategy
			settings.gslb.Spec.Strategy.Type = depresolver.FailoverStrategy
			settings.gslb.Spec.Strategy.PrimaryGeoTag = "us-east-1"
			err = settings.client.Update(context.TODO(), settings.gslb)
			require.NoError(t, err, "Can't update gslb")

			// act
			createHealthyService(t, &settings, serviceName)
			defer deleteHealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to get expected DNSEndpoint")
			got := dnsEndpoint.Spec.Endpoints
			prettyGot := str.ToString(got)
			prettyWant := str.ToString(want)

			// assert
			assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
		}).RequireNoError(t)
}

func TestReturnsExternalRecordsUsingFailoverStrategyAndFallbackDNSserver(t *testing.T) {
	// arrange
	serviceName := "frontend-podinfo"
	want := []*externaldns.Endpoint{
		{
			DNSName:    "localtargets-roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2"},
		},
		{
			DNSName:    "roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.1.0.1", "10.1.0.2"},
			Labels:     externaldns.Labels{"strategy": depresolver.FailoverStrategy},
		},
	}
	ingressIPs := []netv1.IngressLoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	customConfig := predefinedConfig
	customConfig.EdgeDNSServers = []utils.DNSServer{
		{ // this one will be tried frist, but fails
			Host: "localhost",
			Port: 7752,
		},
		{
			Host: "localhost",
			Port: 7753,
		},
		{ // this one fails as well, but shouldn't be tried because the previous works
			Host: "localhost",
			Port: 7754,
		},
	}
	utils.NewFakeDNS(fakeDNSSettings).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 2)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 1)).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, customConfig)

			// ingress
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")

			// enable failover strategy
			settings.gslb.Spec.Strategy.Type = depresolver.FailoverStrategy
			settings.gslb.Spec.Strategy.PrimaryGeoTag = "us-east-1"
			err = settings.client.Update(context.TODO(), settings.gslb)
			require.NoError(t, err, "Can't update gslb")

			// act
			createHealthyService(t, &settings, serviceName)
			defer deleteHealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to get expected DNSEndpoint")
			got := dnsEndpoint.Spec.Endpoints
			prettyGot := str.ToString(got)
			prettyWant := str.ToString(want)

			// assert
			assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
		}).RequireNoError(t)
}

func TestGslbProperlyPropagatesAnnotationDownToIngress(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			expectedAnnotations := map[string]string{"k8gb.io/strategy": "roundRobin"}
			settings := provideSettings(t, predefinedConfig)
			settings.gslb.Annotations = map[string]string{"annotation": "test"}
			err := settings.client.Update(context.TODO(), settings.gslb)
			require.NoError(t, err, "Can't update gslb")
			// act
			reconcileAndUpdateGslb(t, settings)
			err2 := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			// assert
			assert.NoError(t, err2, "Failed to get expected ingress")
			assert.Equal(t, expectedAnnotations, settings.ingress.Annotations)
			// fake client contains single annotation
			// assert.Equal(t, expectedAnnotations, settings.gslb.ObjectMeta.Annotations)
		})
}

func TestReflectGeoTagInStatusAsUnsetByDefault(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			want := "us-west-1"
			settings := provideSettings(t, predefinedConfig)
			// act
			reconcileAndUpdateGslb(t, settings)
			got := settings.gslb.Status.GeoTag
			// assert
			assert.Equal(t, want, got, "got: '%s' GeoTag status, want:'%s'", got, want)
		})
}

func TestReflectGeoTagInTheStatus(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			want := "eu"
			customConfig := predefinedConfig
			customConfig.ClusterGeoTag = "eu"
			settings := provideSettings(t, customConfig)
			// act
			reconcileAndUpdateGslb(t, settings)
			got := settings.gslb.Status.GeoTag
			// assert
			assert.Equal(t, want, got, "got: '%s' GeoTag status, want:'%s'", got, want)
		})
}

func TestDetectsIngressHostnameMismatch(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			// getting Gslb and Reconciler
			predefinedSettings := provideSettings(t, predefinedConfig)
			customConfig := predefinedConfig
			customConfig.EdgeDNSZone = "otherdnszone.com"
			predefinedSettings.config = customConfig
			req := reconcile.Request{
				NamespacedName: types.NamespacedName{
					Name:      predefinedSettings.gslb.Name,
					Namespace: predefinedSettings.gslb.Namespace,
				},
			}
			// injecting custom config to reconciler created from predefined config
			predefinedSettings.reconciler.Config = &customConfig
			// act
			_, err := predefinedSettings.reconciler.Reconcile(context.TODO(), req)
			// assert
			assert.Error(t, err, "expected controller to detect Ingress hostname and edgeDNSZone mismatch")
			assert.True(t, strings.HasSuffix(err.Error(), "cloud.example.com does not match delegated zone otherdnszone.com"))
		})
}

func TestCreatesDNSNSRecordsForExtDNS(t *testing.T) {
	// arrange
	const dnsZone = "cloud.example.com"
	const want = "extdns"
	wantEp := []*externaldns.Endpoint{
		{
			DNSName:    dnsZone,
			RecordTTL:  30,
			RecordType: "NS",
			Targets: externaldns.Targets{
				"gslb-ns-eu-cloud.example.com",
				"gslb-ns-us-cloud.example.com",
				"gslb-ns-za-cloud.example.com",
			},
		},
		{
			DNSName:    "gslb-ns-eu-cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets: externaldns.Targets{
				defaultEdgeDNS0,
				defaultEdgeDNS1,
			},
		},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	customConfig := predefinedConfig
	customConfig.EdgeDNSServers = defaultEdgeDNSServers
	customConfig.CoreDNSExposed = true
	coreDNSService := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      defaultCoreDNSExtServiceName,
			Namespace: predefinedConfig.K8gbNamespace,
			Labels: map[string]string{
				"app.kubernetes.io/name": "coredns",
			},
		},
	}
	serviceIPs := []corev1.LoadBalancerIngress{
		{Hostname: "one.one.one.one"}, // rely on 1.1.1.1 response from Cloudflare
	}
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, customConfig)
			err := settings.client.Create(context.TODO(), coreDNSService)
			require.NoError(t, err, "Failed to create testing %s service", defaultCoreDNSExtServiceName)
			coreDNSService.Status.LoadBalancer.Ingress = append(coreDNSService.Status.LoadBalancer.Ingress, serviceIPs...)
			err = settings.client.Status().Update(context.TODO(), coreDNSService)
			require.NoError(t, err, "Failed to update coredns service lb hostname")

			// act
			customConfig.EdgeDNSType = depresolver.DNSTypeExternal
			customConfig.ClusterGeoTag = "eu"
			customConfig.ExtClustersGeoTags = []string{"za", "us"}
			customConfig.DNSZone = dnsZone
			// apply new environment variables and update config only
			settings.reconciler.Config = &customConfig
			// If config is changed, new Route53 provider needs to be re-created. There is no way and reason to change provider
			// configuration at another time than startup
			f, _ := dns.NewDNSProviderFactory(settings.reconciler.Client, customConfig)
			settings.reconciler.DNSProvider = f.Provider()

			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), client.ObjectKey{Namespace: predefinedConfig.K8gbNamespace, Name: "k8gb-ns-extdns"}, dnsEndpoint)
			require.NoError(t, err, "Failed to get expected DNSEndpoint")
			got := dnsEndpoint.Annotations["k8gb.absa.oss/dnstype"]
			gotEp := dnsEndpoint.Spec.Endpoints
			prettyGot := str.ToString(gotEp)
			prettyWant := str.ToString(wantEp)

			// assert
			assert.Equal(t, want, got, "got:\n %q annotation value,\n\n want:\n %q", got, want)
			assert.Equal(t, wantEp, gotEp, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
		})
}

func TestCreatesDNSNSRecordsForLoadBalancer(t *testing.T) {
	// arrange
	const dnsZone = "cloud.example.com"
	const want = "extdns"
	wantEp := []*externaldns.Endpoint{
		{
			DNSName:    dnsZone,
			RecordTTL:  30,
			RecordType: "NS",
			Targets: externaldns.Targets{
				"gslb-ns-eu-cloud.example.com",
				"gslb-ns-us-cloud.example.com",
				"gslb-ns-za-cloud.example.com",
			},
		},
		{
			DNSName:    "gslb-ns-eu-cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets: externaldns.Targets{
				defaultEdgeDNS1,
			},
		},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	customConfig := predefinedConfig
	customConfig.EdgeDNSServers = defaultEdgeDNSServers
	customConfig.CoreDNSExposed = true
	coreDNSService := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      defaultCoreDNSExtServiceName,
			Namespace: predefinedConfig.K8gbNamespace,
			Labels: map[string]string{
				"app.kubernetes.io/name": "coredns",
			},
		},
	}
	serviceIPs := []corev1.LoadBalancerIngress{
		{IP: "1.1.1.1"},
	}
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, customConfig)
			err := settings.client.Create(context.TODO(), coreDNSService)
			require.NoError(t, err, "Failed to create testing %s service", defaultCoreDNSExtServiceName)
			coreDNSService.Status.LoadBalancer.Ingress = append(coreDNSService.Status.LoadBalancer.Ingress, serviceIPs...)
			err = settings.client.Status().Update(context.TODO(), coreDNSService)
			require.NoError(t, err, "Failed to update coredns service lb hostname")

			// act
			customConfig.EdgeDNSType = depresolver.DNSTypeExternal
			customConfig.ClusterGeoTag = "eu"
			customConfig.ExtClustersGeoTags = []string{"za", "us"}
			customConfig.DNSZone = dnsZone
			// apply new environment variables and update config only
			settings.reconciler.Config = &customConfig
			// If config is changed, new Route53 provider needs to be re-created. There is no way and reason to change provider
			// configuration at another time than startup
			f, _ := dns.NewDNSProviderFactory(settings.reconciler.Client, customConfig)
			settings.reconciler.DNSProvider = f.Provider()

			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), client.ObjectKey{Namespace: predefinedConfig.K8gbNamespace, Name: "k8gb-ns-extdns"}, dnsEndpoint)
			require.NoError(t, err, "Failed to get expected DNSEndpoint")
			got := dnsEndpoint.Annotations["k8gb.absa.oss/dnstype"]
			gotEp := dnsEndpoint.Spec.Endpoints
			prettyGot := str.ToString(gotEp)
			prettyWant := str.ToString(wantEp)

			// assert
			assert.Equal(t, want, got, "got:\n %q annotation value,\n\n want:\n %q", got, want)
			assert.Equal(t, wantEp, gotEp, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
		})
}

func TestResolvesLoadBalancerHostnameFromIngressStatus(t *testing.T) {
	// arrange
	customConfig := predefinedConfig
	serviceName := defaultPodinfoServiceName
	customConfig.EdgeDNSServers = defaultEdgeDNSServers
	want := []*externaldns.Endpoint{
		{
			DNSName:    "localtargets-roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{defaultEdgeDNS0, defaultEdgeDNS1}},
		{
			DNSName:    "roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{defaultEdgeDNS0, defaultEdgeDNS1},
			Labels:     externaldns.Labels{"strategy": "roundRobin"}},
	}
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, customConfig)
			dnsEndpoint := &externaldns.DNSEndpoint{ObjectMeta: metav1.ObjectMeta{Namespace: settings.gslb.Namespace, Name: settings.gslb.Name}}
			createHealthyService(t, &settings, serviceName)
			defer deleteHealthyService(t, &settings, serviceName)
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")

			settings.ingress.Status.LoadBalancer.Ingress = []netv1.IngressLoadBalancerIngress{{Hostname: "one.one.one.one"}}
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")

			// act
			err = settings.client.Delete(context.Background(), dnsEndpoint)
			require.NoError(t, err, "Failed to update DNSEndpoint")
			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to get expected DNSEndpoint")
			got := dnsEndpoint.Spec.Endpoints
			prettyGot := str.ToString(got)
			prettyWant := str.ToString(want)

			// assert
			assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
		})
}

func TestRoute53ZoneDelegationGarbageCollection(t *testing.T) {
	// arrange
	customConfig := predefinedConfig
	settings := provideSettings(t, customConfig)
	coreDNSService := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      defaultCoreDNSExtServiceName,
			Namespace: predefinedConfig.K8gbNamespace,
		},
	}
	serviceIPs := []corev1.LoadBalancerIngress{
		{Hostname: "one.one.one.one"}, // rely on 1.1.1.1 response from Cloudflare
	}

	err := settings.client.Create(context.TODO(), coreDNSService)
	require.NoError(t, err, "Failed to create testing %s service", defaultCoreDNSExtServiceName)
	coreDNSService.Status.LoadBalancer.Ingress = append(coreDNSService.Status.LoadBalancer.Ingress, serviceIPs...)
	err = settings.client.Status().Update(context.TODO(), coreDNSService)
	require.NoError(t, err, "Failed to update coredns service lb hostname")

	// act
	customConfig.EdgeDNSType = depresolver.DNSTypeExternal
	// apply new environment variables and update config only
	settings.reconciler.Config = &customConfig
	reconcileAndUpdateGslb(t, settings)

	err = settings.reconciler.Delete(context.Background(), settings.gslb)
	require.NoError(t, err, "Failed to update Gslb")
	settings.finalCall = true // Gslb is about to be deleted, no requeue expected
	reconcileAndUpdateGslb(t, settings)

	// assert
	dnsEndpointRoute53 := &externaldns.DNSEndpoint{}
	err = settings.client.Get(context.TODO(), client.ObjectKey{Namespace: predefinedConfig.K8gbNamespace, Name: "k8gb-ns-route53"}, dnsEndpointRoute53)
	require.Error(t, err, "k8gb-ns-route53 DNSEndpoint should be garbage collected")
}

func TestGslbSetsAnnotationsOnTheIngress(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			settings := provideSettings(t, predefinedConfig)

			// act
			reconcileAndUpdateGslb(t, settings)

			// assert
			ingress := &netv1.Ingress{}
			err := settings.client.Get(context.Background(), client.ObjectKey{Namespace: settings.gslb.Namespace, Name: settings.gslb.Name}, ingress)
			require.NoError(t, err, "Gslb should be created from annotated Ingress")

			assert.Equal(t, map[string]string{strategyAnnotation: "roundRobin"}, ingress.Annotations)
		})
}

func TestGslbGetFinalizer(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			gslb := &k8gbv1beta1.Gslb{}
			settings := provideSettings(t, predefinedConfig)

			// act
			reconcileAndUpdateGslb(t, settings)

			// assert
			err := settings.reconciler.Get(context.TODO(), settings.request.NamespacedName, gslb)
			require.NoError(t, err)
			assert.Len(t, gslb.Finalizers, 1)
		})
}

func TestGslbRemoveDefaultFinalizer(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			gslb := &k8gbv1beta1.Gslb{}
			settings := provideSettings(t, predefinedConfig)
			err := settings.reconciler.Delete(context.Background(), settings.gslb)
			require.NoError(t, err, "Failed to update Gslb")
			settings.finalCall = true // Gslb is about to be deleted, no requeue expected

			// act
			reconcileAndUpdateGslb(t, settings)

			// assert
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, gslb)
			require.EqualError(t, err, "gslbs.k8gb.absa.oss \"roundrobin-ingress\" not found")
			assert.Len(t, gslb.Finalizers, 0)
		})
}

func TestGslbRemoveWithFinalizer(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			gslb := &k8gbv1beta1.Gslb{}
			settings := provideSettings(t, predefinedConfig)
			settings.gslb.Finalizers = append(settings.gslb.Finalizers, "finalizer.k8gb.absa.oss")
			err := settings.reconciler.Delete(context.Background(), settings.gslb)
			require.NoError(t, err)
			settings.finalCall = true // Gslb is about to be deleted, no requeue expected

			// act
			reconcileAndUpdateGslb(t, settings)

			// assert
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, gslb)
			require.EqualError(t, err, "gslbs.k8gb.absa.oss \"roundrobin-ingress\" not found")
			assert.Len(t, gslb.Finalizers, 0)
		})
}

func TestGslbRemoveBothFinalizers(t *testing.T) {
	utils.NewFakeDNS(fakeDNSSettings).
		Start().
		RunTestFunc(func() {
			// arrange
			gslb := &k8gbv1beta1.Gslb{}
			settings := provideSettings(t, predefinedConfig)
			settings.gslb.Finalizers = append(settings.gslb.Finalizers, "finalizer.k8gb.absa.oss")
			err := settings.client.Delete(context.Background(), settings.gslb)
			require.NoError(t, err, "Failed to update Gslb")
			settings.finalCall = true // Gslb is about to be deleted, no requeue expected

			// act
			reconcileAndUpdateGslb(t, settings)

			// assert
			err = settings.reconciler.Get(context.TODO(), settings.request.NamespacedName, gslb)
			require.EqualError(t, err, "gslbs.k8gb.absa.oss \"roundrobin-ingress\" not found")
			assert.Len(t, gslb.Finalizers, 0)
		})
}

func createHealthyService(t *testing.T, s *testSettings, serviceName string) {
	t.Helper()
	service := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}
	err := s.client.Create(context.TODO(), service)
	if err != nil {
		t.Fatalf("Failed to create testing service: (%v)", err)
	}

	// Create fake endpoint with populated address slice
	endpoint := &corev1.Endpoints{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
		Subsets: []corev1.EndpointSubset{
			{
				Addresses: []corev1.EndpointAddress{{IP: "1.2.3.4"}},
			},
		},
	}

	err = s.client.Create(context.TODO(), endpoint)
	if err != nil {
		t.Fatalf("Failed to create testing endpoint: (%v)", err)
	}
}

func deleteHealthyService(t *testing.T, s *testSettings, serviceName string) {
	t.Helper()
	service := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}
	err := s.client.Delete(context.TODO(), service)
	if err != nil {
		t.Fatalf("Failed to delete testing service: (%v)", err)
	}

	// Create fake endpoint with populated address slice
	endpoint := &corev1.Endpoints{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
		Subsets: []corev1.EndpointSubset{
			{
				Addresses: []corev1.EndpointAddress{{IP: "1.2.3.4"}},
			},
		},
	}

	err = s.client.Delete(context.TODO(), endpoint)
	if err != nil {
		t.Fatalf("Failed to delete testing endpoint: (%v)", err)
	}
}

func createUnhealthyService(t *testing.T, s *testSettings, serviceName string) {
	t.Helper()
	service := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}

	err := s.client.Create(context.TODO(), service)
	if err != nil {
		t.Fatalf("Failed to create testing service: (%v)", err)
	}

	endpoint := &corev1.Endpoints{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}

	err = s.client.Create(context.TODO(), endpoint)
	if err != nil {
		t.Fatalf("Failed to create testing endpoint: (%v)", err)
	}
}

func deleteUnhealthyService(t *testing.T, s *testSettings, serviceName string) {
	t.Helper()
	service := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}

	err := s.client.Delete(context.TODO(), service)
	if err != nil {
		t.Fatalf("Failed to delete testing service: (%v)", err)
	}

	endpoint := &corev1.Endpoints{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}

	err = s.client.Delete(context.TODO(), endpoint)
	if err != nil {
		t.Fatalf("Failed to delete testing endpoint: (%v)", err)
	}

}
func createDNSEndpoint(t *testing.T, s *testSettings) {
	t.Helper()
	dnsEndpoint := &externaldns.DNSEndpoint{
		ObjectMeta: metav1.ObjectMeta{
			Name:      s.gslb.Name,
			Namespace: s.gslb.Namespace,
		},
	}
	err := s.client.Create(context.TODO(), dnsEndpoint)
	if err != nil {
		t.Fatalf("Failed to create testing DNSEndpoint: (%v)", err)
	}
}

func deleteDNSEndpoint(t *testing.T, s *testSettings) {
	t.Helper()
	endpoint := &externaldns.DNSEndpoint{
		ObjectMeta: metav1.ObjectMeta{
			Name:      s.gslb.Name,
			Namespace: s.gslb.Namespace,
		},
	}
	err := s.client.Delete(context.TODO(), endpoint)
	if err != nil {
		t.Fatalf("Failed to delete testing DNSEndpoint: (%v)", err)
	}
}

func reconcileAndUpdateGslb(t *testing.T, s testSettings) {
	t.Helper()
	// Reconcile again so Reconcile() checks services and updates the Gslb
	// resources' Status.
	res, err := s.reconciler.Reconcile(context.TODO(), s.request)
	if err != nil {
		return
	}

	if !s.finalCall {
		if res != (reconcile.Result{RequeueAfter: time.Second * 30}) {
			t.Error("reconcile did not return Result with Requeue")
		}
		err = s.reconciler.Get(context.TODO(), s.request.NamespacedName, s.gslb)
		if err != nil {
			t.Fatalf("Failed to get expected gslb: (%v)", err)
		}
	}

}

func provideSettings(t *testing.T, expected depresolver.Config) (settings testSettings) {
	_, err := os.Stat(crSampleYaml)
	if os.IsNotExist(err) {
		t.Fatalf("Sample CR yaml file not found at: %s", crSampleYaml)
	}
	gslbYaml, err := os.ReadFile(crSampleYaml)
	if err != nil {
		t.Fatalf("Can't open example CR file: %s", crSampleYaml)
	}
	// Set the log to development mode for verbose logs.
	gslb, err := utils.YamlToGslb(gslbYaml)
	if err != nil {
		t.Fatal(err)
	}
	objs := []runtime.Object{
		gslb,
	}
	// Register operator types with the runtime scheme.
	s := scheme.Scheme
	s.AddKnownTypes(k8gbv1beta1.GroupVersion, gslb)
	// Register external-dns DNSEndpoint CRD
	s.AddKnownTypes(schema.GroupVersion{Group: "externaldns.k8s.io", Version: "v1alpha1"}, &externaldns.DNSEndpoint{})
	// Create a fake client to mock API calls.
	// https://github.com/kubernetes-sigs/controller-runtime/issues/2362
	cl := fake.NewClientBuilder().WithScheme(s).WithStatusSubresource(gslb).WithRuntimeObjects(objs...).Build()

	// tracing
	cfg := tracing.Settings{
		Enabled:       expected.TracingEnabled,
		Endpoint:      expected.OtelExporterOtlpEndpoint,
		SamplingRatio: expected.TracingSamplingRatio,
		Commit:        "commit",
		AppVersion:    "version",
	}
	cleanup, tracer := tracing.SetupTracing(context.Background(), cfg, log)
	defer cleanup()
	// Create a GslbReconciler object with the scheme and fake client.
	r := &GslbReconciler{
		Client: cl,
		Scheme: s,
		Tracer: tracer,
	}
	r.DepResolver = depresolver.NewDependencyResolver()
	r.Config = &expected
	// Mock request to simulate Reconcile() being called on an event for a
	// watched resource .
	req := reconcile.Request{
		NamespacedName: types.NamespacedName{
			Name:      gslb.Name,
			Namespace: gslb.Namespace,
		},
	}

	var f *dns.ProviderFactory
	f, err = dns.NewDNSProviderFactory(r.Client, *r.Config)
	if err != nil {
		t.Fatalf("reconcile: (%v)", err)
	}
	r.DNSProvider = f.Provider()
	a := assistant.NewGslbAssistant(r.Client, r.Config.K8gbNamespace, r.Config.EdgeDNSServers)
	res, err := r.Reconcile(context.TODO(), req)
	if err != nil {
		t.Fatalf("reconcile: (%v)", err)
	}

	if res.Requeue {
		t.Error("requeue expected")
	}
	ingress := &netv1.Ingress{}
	err = cl.Get(context.TODO(), req.NamespacedName, ingress)
	if err != nil {
		t.Fatalf("Failed to get expected ingress: (%v)", err)
	}

	// Reconcile again so Reconcile() checks services and updates the Gslb
	// resources' Status.
	settings = testSettings{
		gslb:       gslb,
		config:     expected,
		reconciler: r,
		request:    req,
		client:     cl,
		ingress:    ingress,
		finalCall:  false,
		assistant:  a,
	}
	reconcileAndUpdateGslb(t, settings)
	return settings
}

func oldEdgeTimestamp(threshold string) string {
	now := time.Now()
	duration, _ := time.ParseDuration(threshold)
	before := now.Add(-duration)
	edgeTimestamp := fmt.Sprint(before.UTC().Format("2006-01-02T15:04:05"))
	return edgeTimestamp
}

func TestMain(m *testing.M) {
	var exitCode int
	defer func() {
		metrics.Metrics().Unregister()
		os.Exit(exitCode)
	}()
	logging.Init(&predefinedConfig)
	metrics.Init(&predefinedConfig)
	err := metrics.Metrics().Register()
	if err != nil {
		logging.Logger().Fatal().Err(err).Msg("metrics register")
	}
	exitCode = m.Run()
}
