package refresolver

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

/*
Copyright 2024 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"fmt"
	"reflect"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	"github.com/k8gb-io/k8gb/controllers/internal/utils"
	netv1 "k8s.io/api/networking/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type IngressReferenceResolver struct {
	ingress *netv1.Ingress
}

// NewIngressReferenceResolver creates a reference resolver capable of understanding ingresses.networking.k8s.io resources
func NewIngressReferenceResolver(gslb *k8gbv1beta1.Gslb, k8sClient client.Client) (*IngressReferenceResolver, error) {
	ingressList, err := getGslbIngressRef(gslb, k8sClient)
	if err != nil {
		return nil, err
	}
	ingressEmbedded, err := getGslbIngressEmbedded(gslb, k8sClient)
	if err != nil {
		return nil, err
	}
	if ingressEmbedded != nil {
		ingressList = append(ingressList, *ingressEmbedded)
	}

	for _, ingress := range ingressList {
		log.Info().
			Str("IngressName", ingress.Name).
			Msg("Found Ingress")
	}

	if len(ingressList) != 1 {
		return nil, fmt.Errorf("exactly one Ingress resource expected but %d were found", len(ingressList))
	}

	return &IngressReferenceResolver{
		ingress: &ingressList[0],
	}, nil
}

// getGslbIngressRef resolves a Kubernetes Ingress resource referenced by the Gslb spec
func getGslbIngressRef(gslb *k8gbv1beta1.Gslb, k8sClient client.Client) ([]netv1.Ingress, error) {
	ingressList := &netv1.IngressList{}
	if reflect.DeepEqual(gslb.Spec.ResourceRef.Ingress, metav1.LabelSelector{}) {
		log.Info().
			Str("gslb", gslb.Name).
			Msg("No configuration for referenced Ingress resource")
		return ingressList.Items, nil
	}

	selector, err := metav1.LabelSelectorAsSelector(&gslb.Spec.ResourceRef.Ingress)
	if err != nil {
		return nil, err
	}
	opts := &client.ListOptions{
		LabelSelector: selector,
	}

	err = k8sClient.List(context.TODO(), ingressList, opts)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Info().
				Str("gslb", gslb.Name).
				Msg("Can't find referenced Ingress resource")
		}
		return nil, err
	}

	return ingressList.Items, err
}

// getGslbIngressEmbedded resolves a Kubernetes Ingress resource embedded in the Gslb spec
func getGslbIngressEmbedded(gslb *k8gbv1beta1.Gslb, k8sClient client.Client) (*netv1.Ingress, error) {
	if reflect.DeepEqual(gslb.Spec.Ingress, k8gbv1beta1.IngressSpec{}) {
		log.Info().
			Str("gslb", gslb.Name).
			Msg("No configuration for embedded Ingress resource")
		return nil, nil
	}

	nn := types.NamespacedName{
		Name:      gslb.Name,
		Namespace: gslb.Namespace,
	}
	ingress := &netv1.Ingress{}
	err := k8sClient.Get(context.TODO(), nn, ingress)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Warn().
				Str("gslb", gslb.Name).
				Msg("Can't find gslb Ingress")
		}
		return nil, err
	}

	return ingress, nil
}

// GetServers retrieves the backend servers referenced by the GSLB
func (irr *IngressReferenceResolver) GetServers() ([]*k8gbv1beta1.Server, error) {
	servers := []*k8gbv1beta1.Server{}

	for _, rule := range irr.ingress.Spec.Rules {
		server := &k8gbv1beta1.Server{
			Host:     rule.Host,
			Services: []*k8gbv1beta1.NamespacedName{},
		}
		for _, path := range rule.HTTP.Paths {
			if path.Backend.Service == nil || path.Backend.Service.Name == "" {
				log.Warn().
					Str("ingress", irr.ingress.Name).
					Interface("service", path.Backend.Service).
					Msg("Malformed service definition")
				continue
			}

			server.Services = append(server.Services, &k8gbv1beta1.NamespacedName{
				Name:      path.Backend.Service.Name,
				Namespace: irr.ingress.Namespace,
			})
		}
		servers = append(servers, server)
	}

	return servers, nil
}

// GetGslbExposedIPs retrieves the load balancer IP address of the GSLB
func (irr *IngressReferenceResolver) GetGslbExposedIPs(gslb *k8gbv1beta1.Gslb, _ client.Client, edgeDNSServers utils.DNSList) ([]string, error) {
	gslbIngressIPs := []string{}

	for _, ip := range irr.ingress.Status.LoadBalancer.Ingress {
		if len(ip.IP) > 0 {
			gslbIngressIPs = append(gslbIngressIPs, ip.IP)
		}
		if len(ip.Hostname) > 0 {
			IPs, err := utils.Dig(ip.Hostname, edgeDNSServers...)
			if err != nil {
				log.Warn().Err(err).Msg("Dig error")
				return nil, err
			}
			gslbIngressIPs = append(gslbIngressIPs, IPs...)
		}
	}

	return gslbIngressIPs, nil
}

func (irr *IngressReferenceResolver) getIngress() *netv1.Ingress {
	return irr.ingress
}
