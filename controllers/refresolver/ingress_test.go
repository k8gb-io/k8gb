package refresolver

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

/*
Copyright 2024 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"fmt"
	"os"
	"testing"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	"github.com/k8gb-io/k8gb/controllers/utils"
	"github.com/stretchr/testify/assert"
	netv1 "k8s.io/api/networking/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
)

func TestGetIngress(t *testing.T) {
	var tests = []struct {
		name                string
		gslbYaml            string
		expectedIngressYaml string
		expectedError       error
	}{
		{
			name:                "embedded ingress",
			gslbYaml:            "./testdata/gslb_embedded.yaml",
			expectedIngressYaml: "./testdata/ingress_embedded.yaml",
			expectedError:       nil,
		},
		{
			name:                "referenced ingress",
			gslbYaml:            "./testdata/gslb_referenced.yaml",
			expectedIngressYaml: "./testdata/ingress_referenced.yaml",
			expectedError:       nil,
		},
		{
			name:                "referenced and embedded ingress",
			gslbYaml:            "./testdata/gslb_referenced_and_embedded.yaml",
			expectedIngressYaml: "",
			expectedError:       fmt.Errorf("exactly one Ingress resource expected but 2 were found"),
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			// arrange
			cl, gslb := getTestContext(test.gslbYaml)

			// act
			resolver, err := New(gslb, cl)
			assert.Equal(t, test.expectedError, err)

			ingressResolver, ok := resolver.(*IngressReferenceResolver)
			assert.True(t, ok, "referenced resolver is of type Ingress")

			// assert
			if test.expectedIngressYaml != "" {
				expectedIngress := fileToIngress(test.expectedIngressYaml)
				assert.Equal(t, expectedIngress, ingressResolver.getIngress())
			}
		})
	}
}

func TestGetServers(t *testing.T) {
	var tests = []struct {
		name            string
		ingressYaml     string
		expectedServers []*k8gbv1beta1.Server
	}{
		{
			name:        "multiple servers",
			ingressYaml: "./testdata/ingress_multiple_servers.yaml",
			expectedServers: []*k8gbv1beta1.Server{
				{
					Host: "h1.cloud.example.com",
					Services: []*k8gbv1beta1.NamespacedName{
						{
							Name:      "s1",
							Namespace: "test-gslb",
						},
					},
				},
				{
					Host: "h2.cloud.example.com",
					Services: []*k8gbv1beta1.NamespacedName{
						{
							Name:      "ss1",
							Namespace: "test-gslb",
						},
						{
							Name:      "ss2",
							Namespace: "test-gslb",
						},
					},
				},
			},
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			// arrange
			ingress := fileToIngress(test.ingressYaml)
			resolver := IngressReferenceResolver{
				ingress: ingress,
			}

			// act
			servers, err := resolver.GetServers()
			assert.NoError(t, err)

			// assert
			assert.Equal(t, test.expectedServers, servers)
		})
	}
}

func TestGetGslbExposedIPs(t *testing.T) {
	var tests = []struct {
		name        string
		ingressYaml string
		expectedIPs []string
	}{
		{
			name:        "multiple exposed IPs",
			ingressYaml: "./testdata/ingress_multiple_servers.yaml",
			expectedIPs: []string{"10.0.0.1", "10.0.0.2"},
		},
		{
			name:        "no exposed IPs",
			ingressYaml: "./testdata/ingress_referenced.yaml",
			expectedIPs: []string{},
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			// arrange
			ingress := fileToIngress(test.ingressYaml)
			resolver := IngressReferenceResolver{
				ingress: ingress,
			}

			// act
			IPs, err := resolver.GetGslbExposedIPs(nil, []utils.DNSServer{})
			assert.NoError(t, err)

			// assert
			assert.Equal(t, test.expectedIPs, IPs)
		})
	}
}

func getTestContext(gslbData string) (client.Client, *k8gbv1beta1.Gslb) {
	gslbYaml, err := os.ReadFile(gslbData)
	if err != nil {
		panic(fmt.Errorf("can't open example CR file: %s", gslbData))
	}
	gslb, err := utils.YamlToGslb(gslbYaml)
	if err != nil {
		panic(err)
	}

	objs := []runtime.Object{
		gslb,
		fileToIngress("./testdata/ingress_embedded.yaml"),
		fileToIngress("./testdata/ingress_referenced.yaml"),
	}
	// Register operator types with the runtime scheme.
	s := scheme.Scheme
	s.AddKnownTypes(k8gbv1beta1.GroupVersion, gslb)
	cl := fake.NewClientBuilder().WithScheme(s).WithRuntimeObjects(objs...).Build()

	return cl, gslb
}

func fileToIngress(ingressData string) *netv1.Ingress {
	ingressYaml, err := os.ReadFile(ingressData)
	if err != nil {
		panic(fmt.Errorf("can't open example CR file: %s", ingressData))
	}
	ingress, err := utils.YamlToIngress(ingressYaml)
	if err != nil {
		panic(err)
	}
	return ingress
}
