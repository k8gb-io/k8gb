package ingress

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"fmt"
	"reflect"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	"github.com/k8gb-io/k8gb/controllers/logging"
	"github.com/k8gb-io/k8gb/controllers/utils"
	netv1 "k8s.io/api/networking/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

var log = logging.Logger()

type ReferenceResolver struct {
	ingress *netv1.Ingress
}

// NewReferenceResolver creates a reference resolver capable of understanding referenced ingresses.networking.k8s.io resources
func NewReferenceResolver(gslb *k8gbv1beta1.Gslb, k8sClient client.Client) (*ReferenceResolver, error) {
	ingressList, err := getGslbIngressRef(gslb, k8sClient)
	if err != nil {
		return nil, err
	}
	for _, ingress := range ingressList {
		log.Info().
			Str("Name", ingress.Name).
			Msg("Found Ingress")
	}

	if len(ingressList) != 1 {
		return nil, fmt.Errorf("exactly one Ingress resource expected but %d were found", len(ingressList))
	}

	return &ReferenceResolver{
		ingress: &ingressList[0],
	}, nil
}

// getGslbIngressRef resolves a Kubernetes Ingress resource referenced by the Gslb spec
func getGslbIngressRef(gslb *k8gbv1beta1.Gslb, k8sClient client.Client) ([]netv1.Ingress, error) {
	ingressList := &netv1.IngressList{}

	selector, err := metav1.LabelSelectorAsSelector(&gslb.Spec.ResourceRef.LabelSelector)
	if err != nil {
		return nil, err
	}
	opts := &client.ListOptions{
		LabelSelector: selector,
		Namespace:     gslb.Namespace,
	}

	err = k8sClient.List(context.TODO(), ingressList, opts)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Info().
				Str("gslb", gslb.Name).
				Msg("Can't find referenced Ingress resource")
		}
		return nil, err
	}

	return ingressList.Items, err
}

// NewEmbeddedResolver creates a reference resolver capable of understanding embedded ingresses.networking.k8s.io resources
func NewEmbeddedResolver(gslb *k8gbv1beta1.Gslb, k8sClient client.Client) (*ReferenceResolver, error) {
	ingressEmbedded, err := getGslbIngressEmbedded(gslb, k8sClient)
	if err != nil {
		return nil, err
	}
	if ingressEmbedded == nil {
		return nil, fmt.Errorf("exactly one Ingress resource expected but none was found")
	}

	return &ReferenceResolver{
		ingress: ingressEmbedded,
	}, nil
}

// getGslbIngressEmbedded resolves a Kubernetes Ingress resource embedded in the Gslb spec
func getGslbIngressEmbedded(gslb *k8gbv1beta1.Gslb, k8sClient client.Client) (*netv1.Ingress, error) {
	if reflect.DeepEqual(gslb.Spec.Ingress, k8gbv1beta1.IngressSpec{}) {
		log.Info().
			Str("gslb", gslb.Name).
			Msg("No configuration for embedded Ingress resource")
		return nil, nil
	}

	nn := types.NamespacedName{
		Name:      gslb.Name,
		Namespace: gslb.Namespace,
	}
	ingress := &netv1.Ingress{}
	err := k8sClient.Get(context.TODO(), nn, ingress)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Warn().
				Str("gslb", gslb.Name).
				Msg("Can't find gslb Ingress")
		}
		return nil, err
	}

	return ingress, nil
}

// GetServers retrieves the GSLB server configuration from the gateway resource
func (rr *ReferenceResolver) GetServers() ([]*k8gbv1beta1.Server, error) {
	servers := []*k8gbv1beta1.Server{}

	for _, rule := range rr.ingress.Spec.Rules {
		server := &k8gbv1beta1.Server{
			Host:     rule.Host,
			Services: []*k8gbv1beta1.NamespacedName{},
		}
		for _, path := range rule.HTTP.Paths {
			if path.Backend.Service == nil || path.Backend.Service.Name == "" {
				log.Warn().
					Str("ingress", rr.ingress.Name).
					Interface("service", path.Backend.Service).
					Msg("Malformed service definition")
				continue
			}

			server.Services = append(server.Services, &k8gbv1beta1.NamespacedName{
				Name:      path.Backend.Service.Name,
				Namespace: rr.ingress.Namespace,
			})
		}
		servers = append(servers, server)
	}

	return servers, nil
}

// GetGslbExposedIPs retrieves the load balancer IP address of the GSLB
func (rr *ReferenceResolver) GetGslbExposedIPs(edgeDNSServers utils.DNSList) ([]string, error) {
	gslbIngressIPs := []string{}

	for _, ip := range rr.ingress.Status.LoadBalancer.Ingress {
		if len(ip.IP) > 0 {
			gslbIngressIPs = append(gslbIngressIPs, ip.IP)
		}
		if len(ip.Hostname) > 0 {
			IPs, err := utils.Dig(ip.Hostname, edgeDNSServers...)
			if err != nil {
				log.Warn().Err(err).Msg("Dig error")
				return nil, err
			}
			gslbIngressIPs = append(gslbIngressIPs, IPs...)
		}
	}

	return gslbIngressIPs, nil
}
