package ingress

/*
Copyright 2021-2025 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"fmt"
	"reflect"

	"github.com/k8gb-io/k8gb/controllers/refresolver/queryopts"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	"github.com/k8gb-io/k8gb/controllers/logging"
	"github.com/k8gb-io/k8gb/controllers/utils"
	corev1 "k8s.io/api/core/v1"
	netv1 "k8s.io/api/networking/v1"
	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

var log = logging.Logger()

type ReferenceResolver struct {
	ingress   *netv1.Ingress
	k8sClient client.Client
}

// NewReferenceResolver creates a reference resolver capable of understanding referenced ingresses.networking.k8s.io resources
func NewReferenceResolver(gslb *k8gbv1beta1.Gslb, k8sClient client.Client) (*ReferenceResolver, error) {
	ingressList, err := getGslbIngressRef(gslb, k8sClient)
	if err != nil {
		return nil, err
	}
	for _, ingress := range ingressList {
		log.Info().
			Str("Name", ingress.Name).
			Msg("Found Ingress")
	}

	if len(ingressList) != 1 {
		return nil, fmt.Errorf("exactly 1 Ingress resource expected but %d were found", len(ingressList))
	}

	return &ReferenceResolver{
		ingress:   &ingressList[0],
		k8sClient: k8sClient,
	}, nil
}

// getGslbIngressRef resolves a Kubernetes Ingress resource referenced by the Gslb spec
func getGslbIngressRef(gslb *k8gbv1beta1.Gslb, k8sClient client.Client) ([]netv1.Ingress, error) {
	query, err := queryopts.Get(gslb.Spec.ResourceRef, gslb.Namespace)
	if err != nil {
		return nil, err
	}

	switch query.Mode {
	case queryopts.QueryModeGet:
		var ing = netv1.Ingress{}
		err = k8sClient.Get(context.TODO(), *query.GetKey, &ing)
		if err != nil {
			if k8serrors.IsNotFound(err) {
				log.Info().
					Str("gslb", gslb.Name).
					Str("namespace", gslb.Namespace).
					Msg("Can't find referenced Ingress resource")
			}
			return nil, err
		}
		return []netv1.Ingress{ing}, nil

	case queryopts.QueryModeList:
		var ingList netv1.IngressList
		err = k8sClient.List(context.TODO(), &ingList, query.ListOpts...)
		if err != nil {
			if k8serrors.IsNotFound(err) {
				log.Info().
					Str("gslb", gslb.Name).
					Str("namespace", gslb.Namespace).
					Msg("Can't find referenced Ingress resource")
			}
			return nil, err
		}
		return ingList.Items, nil
	}
	return nil, fmt.Errorf("unknown query mode %v", query.Mode)
}

// NewEmbeddedResolver creates a reference resolver capable of understanding embedded ingresses.networking.k8s.io resources
func NewEmbeddedResolver(gslb *k8gbv1beta1.Gslb, k8sClient client.Client) (*ReferenceResolver, error) {
	ingressEmbedded, err := getGslbIngressEmbedded(gslb, k8sClient)
	if err != nil {
		return nil, err
	}
	if ingressEmbedded == nil {
		return nil, fmt.Errorf("exactly 1 Ingress resource expected but none was found")
	}

	return &ReferenceResolver{
		ingress:   ingressEmbedded,
		k8sClient: k8sClient,
	}, nil
}

// getGslbIngressEmbedded resolves a Kubernetes Ingress resource embedded in the Gslb spec
func getGslbIngressEmbedded(gslb *k8gbv1beta1.Gslb, k8sClient client.Client) (*netv1.Ingress, error) {
	if reflect.DeepEqual(gslb.Spec.Ingress, k8gbv1beta1.IngressSpec{}) {
		log.Info().
			Str("gslb", gslb.Name).
			Msg("No configuration for embedded Ingress resource")
		return nil, nil
	}

	nn := types.NamespacedName{
		Name:      gslb.Name,
		Namespace: gslb.Namespace,
	}
	ingress := &netv1.Ingress{}
	err := k8sClient.Get(context.TODO(), nn, ingress)
	if err != nil {
		if k8serrors.IsNotFound(err) {
			log.Warn().
				Str("gslb", gslb.Name).
				Msg("Can't find gslb Ingress")
		}
		return nil, err
	}

	return ingress, nil
}

// GetServers retrieves the GSLB server configuration from the gateway resource
func (rr *ReferenceResolver) GetServers() ([]*k8gbv1beta1.Server, error) {
	servers := []*k8gbv1beta1.Server{}

	for _, rule := range rr.ingress.Spec.Rules {
		server := &k8gbv1beta1.Server{
			Host:     rule.Host,
			Services: []*k8gbv1beta1.NamespacedName{},
		}
		for _, path := range rule.HTTP.Paths {
			if path.Backend.Service == nil || path.Backend.Service.Name == "" {
				log.Warn().
					Str("ingress", rr.ingress.Name).
					Msg("Malformed service definition")
				continue
			}

			server.Services = append(server.Services, &k8gbv1beta1.NamespacedName{
				Name:      path.Backend.Service.Name,
				Namespace: rr.ingress.Namespace,
			})
		}
		servers = append(servers, server)
	}

	return servers, nil
}

// GetGslbExposedIPs retrieves the load balancer IP address of the GSLB
func (rr *ReferenceResolver) GetGslbExposedIPs(gslbAnnotations map[string]string, parentZoneDNSServers utils.DNSList) ([]string, error) {
	// fetch the IP addresses of the reverse proxy from an annotation if it exists
	if ingressIPsFromAnnotation, ok := gslbAnnotations[utils.ExternalIPsAnnotation]; ok {
		return utils.ParseIPAddresses(ingressIPsFromAnnotation)
	}

	// if there is no annotation -> fetch the IP addresses from the Status of the Ingress resource
	gslbIngressIPs := []string{}
	for _, ip := range rr.ingress.Status.LoadBalancer.Ingress {
		if len(ip.IP) > 0 {
			gslbIngressIPs = append(gslbIngressIPs, ip.IP)
		}
		if len(ip.Hostname) > 0 {
			IPs, err := utils.Dig(ip.Hostname, 8, parentZoneDNSServers...)
			if err != nil {
				log.Warn().Err(err).Msg("Dig error")
				return nil, err
			}
			gslbIngressIPs = append(gslbIngressIPs, IPs...)
		}
	}

	return gslbIngressIPs, nil
}

// GetLbService retrieves the service that exposes the ingress controller
// It uses a hybrid discovery approach:
// 1. Get exposed IP addresses/hostnames from the Ingress status
// 2. Find services with label "k8gb.io/ingress-controller-service=true" that match those IPs/hostnames
// This ensures we discover the correct ingress controller even when multiple controllers exist
// Supports both IP-based (GCP/Azure) and hostname-based (AWS ELB) load balancers
func (rr *ReferenceResolver) GetLbService(ctx context.Context) (*k8gbv1beta1.NamespacedName, error) {
	// Step 1: Get exposed IPs and hostnames from Ingress status
	ingressIPs, ingressHostnames := rr.getIngressAddresses()
	if len(ingressIPs) == 0 && len(ingressHostnames) == 0 {
		log.Debug().
			Str("ingress", rr.ingress.Name).
			Msg("No IPs or hostnames in Ingress status - ingress controller service discovery skipped")
		return nil, nil
	}

	log.Debug().
		Str("ingress", rr.ingress.Name).
		Strs("ingressIPs", ingressIPs).
		Strs("ingressHostnames", ingressHostnames).
		Msg("Found addresses in Ingress status")

	// Step 2: Get all services with the k8gb label
	serviceList := &corev1.ServiceList{}
	opts := &client.ListOptions{
		LabelSelector: labels.SelectorFromSet(map[string]string{
			"k8gb.io/ingress-controller-service": "true",
		}),
	}

	err := rr.k8sClient.List(ctx, serviceList, opts)
	if err != nil {
		// Differentiate error types for better debugging
		if k8serrors.IsForbidden(err) {
			log.Error().
				Err(err).
				Msg("Insufficient RBAC permissions to list services - check ClusterRole configuration")
			return nil, fmt.Errorf("insufficient RBAC permissions to list services: %w", err)
		}
		if k8serrors.IsTimeout(err) {
			log.Warn().
				Err(err).
				Msg("Timeout listing services - API server may be slow or overloaded")
			return nil, fmt.Errorf("timeout listing services: %w", err)
		}
		log.Warn().
			Err(err).
			Msg("Failed to list services with k8gb.io/ingress-controller-service label")
		return nil, fmt.Errorf("failed to list services: %w", err)
	}

	if len(serviceList.Items) == 0 {
		log.Debug().Msg("No services found with label k8gb.io/ingress-controller-service=true")
		return nil, nil
	}

	log.Debug().
		Int("count", len(serviceList.Items)).
		Msg("Found services with k8gb.io/ingress-controller-service label")

	// Step 3: Filter services by matching IPs/hostnames
	var matchedServices []matchedService
	for i := range serviceList.Items {
		svc := &serviceList.Items[i]

		// Only consider LoadBalancer services
		if svc.Spec.Type != corev1.ServiceTypeLoadBalancer {
			log.Debug().
				Str("serviceName", svc.Name).
				Str("serviceNamespace", svc.Namespace).
				Str("serviceType", string(svc.Spec.Type)).
				Msg("Skipping non-LoadBalancer service")
			continue
		}

		// Get service IPs and hostnames
		serviceIPs, serviceHostnames := getServiceAddresses(svc)
		if len(serviceIPs) == 0 && len(serviceHostnames) == 0 {
			log.Debug().
				Str("serviceName", svc.Name).
				Str("serviceNamespace", svc.Namespace).
				Msg("Service has no IPs or hostnames in status")
			continue
		}

		// Check if any ingress address matches any service address
		matchedIPs, matchedHostnames := findMatches(ingressIPs, ingressHostnames, serviceIPs, serviceHostnames)
		if len(matchedIPs) > 0 || len(matchedHostnames) > 0 {
			matchedServices = append(matchedServices, matchedService{
				namespace:        svc.Namespace,
				name:             svc.Name,
				matchedIPs:       matchedIPs,
				matchedHostnames: matchedHostnames,
			})
			log.Debug().
				Str("serviceName", svc.Name).
				Str("serviceNamespace", svc.Namespace).
				Strs("matchedIPs", matchedIPs).
				Strs("matchedHostnames", matchedHostnames).
				Msg("Found service with matching addresses")
		} else {
			log.Debug().
				Str("serviceName", svc.Name).
				Str("serviceNamespace", svc.Namespace).
				Strs("serviceIPs", serviceIPs).
				Strs("serviceHostnames", serviceHostnames).
				Strs("ingressIPs", ingressIPs).
				Strs("ingressHostnames", ingressHostnames).
				Msg("Service addresses don't match Ingress addresses")
		}
	}

	// Step 4: Validate results
	if len(matchedServices) == 0 {
		log.Debug().
			Strs("ingressIPs", ingressIPs).
			Strs("ingressHostnames", ingressHostnames).
			Int("labeledServices", len(serviceList.Items)).
			Msg("No labeled service found with matching addresses")
		return nil, nil
	}

	if len(matchedServices) > 1 {
		// Multiple services matched even after IP/DNS filtering - this is ambiguous
		log.Error().
			Int("matchedCount", len(matchedServices)).
			Interface("matchedServices", matchedServices).
			Msg("Multiple services matched after IP/DNS filtering - label k8gb.io/ingress-controller-service=true must be unique per ingress controller")
		return nil, fmt.Errorf(
			"multiple services matched (%d services) after IP/DNS filtering - label k8gb.io/ingress-controller-service=true must be unique",
			len(matchedServices))
	}

	// Exactly one match - success!
	matched := matchedServices[0]
	log.Info().
		Str("serviceName", matched.name).
		Str("serviceNamespace", matched.namespace).
		Strs("matchedIPs", matched.matchedIPs).
		Strs("matchedHostnames", matched.matchedHostnames).
		Msg("Discovered ingress controller service via label + address matching")

	return &k8gbv1beta1.NamespacedName{
		Namespace: matched.namespace,
		Name:      matched.name,
	}, nil
}

// matchedService represents a service that matched the ingress addresses
type matchedService struct {
	namespace        string
	name             string
	matchedIPs       []string
	matchedHostnames []string
}

// getIngressAddresses extracts both IPs and hostnames from the Ingress status
// This supports both IP-based load balancers (GCP/Azure) and hostname-based (AWS ELB)
func (rr *ReferenceResolver) getIngressAddresses() (ips []string, hostnames []string) {
	for _, ing := range rr.ingress.Status.LoadBalancer.Ingress {
		if ing.IP != "" {
			ips = append(ips, ing.IP)
		}
		if ing.Hostname != "" {
			hostnames = append(hostnames, ing.Hostname)
		}
	}
	return ips, hostnames
}

// getServiceAddresses extracts both IPs and hostnames from a LoadBalancer service status
// This supports both IP-based load balancers (GCP/Azure) and hostname-based (AWS ELB)
func getServiceAddresses(svc *corev1.Service) (ips []string, hostnames []string) {
	for _, ing := range svc.Status.LoadBalancer.Ingress {
		if ing.IP != "" {
			ips = append(ips, ing.IP)
		}
		if ing.Hostname != "" {
			hostnames = append(hostnames, ing.Hostname)
		}
	}
	return ips, hostnames
}

// findMatches checks if any address from ingress matches any address from service
// Returns the matched IPs and hostnames separately for logging purposes
func findMatches(ingressIPs, ingressHostnames, serviceIPs, serviceHostnames []string) (matchedIPs, matchedHostnames []string) {
	// Build sets for O(1) lookup
	serviceIPSet := make(map[string]bool)
	for _, ip := range serviceIPs {
		serviceIPSet[ip] = true
	}

	serviceHostnameSet := make(map[string]bool)
	for _, hostname := range serviceHostnames {
		serviceHostnameSet[hostname] = true
	}

	// Find matching IPs
	for _, ip := range ingressIPs {
		if serviceIPSet[ip] {
			matchedIPs = append(matchedIPs, ip)
		}
	}

	// Find matching hostnames
	for _, hostname := range ingressHostnames {
		if serviceHostnameSet[hostname] {
			matchedHostnames = append(matchedHostnames, hostname)
		}
	}

	return matchedIPs, matchedHostnames
}
