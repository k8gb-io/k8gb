package depresolver

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"fmt"
	"os"
	"strconv"
	"strings"
	"testing"

	utils2 "github.com/k8gb-io/k8gb/controllers/utils"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/kubernetes/scheme"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
	externaldns "sigs.k8s.io/external-dns/endpoint"
)

const (
	defaultDNSZone          = "k8gb-test-preprod.gslb.cloud.example.com"
	defaultEdgeDNSZone      = "cloud.example.com"
	defaultVersion          = "0.0.1"
	defaultHost             = "test.domain"
	defaultInfobloxUsername = "foo"
	defaultInfobloxPassword = "blah"
	defaultClusterGeoTagUs1 = "us-west-1"
	defaultClusterGeoTagUs2 = "us-east-1"
	defaultClusterGeoTagEu  = "eu-central-1"
	defaultEdgeDNSServerIP  = "10.0.40.2"
	defaultDNSZones         = "example.com:cloud.example.com:300"
)

var predefinedConfig = Config{
	ReconcileRequeueSeconds: 30,
	NSRecordTTL:             30,
	CoreDNSServiceType:      "ClusterIP",
	ClusterGeoTag:           "us",
	extClustersGeoTags:      []string{"za", "eu"},
	EdgeDNSType:             DNSTypeInfoblox,
	EdgeDNSServers: []utils2.DNSServer{
		{
			Host: "dns.cloud.example.com",
			Port: 53,
		},
	},
	fallbackEdgeDNSServerName: "",
	fallbackEdgeDNSServerPort: 53,
	dnsZones:                  defaultDNSZones,
	K8gbNamespace:             "k8gb",
	MetricsAddress:            "0.0.0.0:8080",
	Infoblox: Infoblox{
		"Infoblox.host.com",
		"0.0.3",
		443,
		"Infoblox",
		"secret",
		21,
		11,
	},
	Log: Log{
		Format: SimpleFormat,
		format: SimpleFormat.String(),
		level:  zerolog.DebugLevel.String(),
	},
}

func TestResolveSpecWithFilledFields(t *testing.T) {
	// arrange
	cl, gslb := getTestContext("./testdata/filled_omitempty.yaml")
	resolver := NewDependencyResolver()
	// act
	err := resolver.ResolveGslbSpec(context.TODO(), gslb, cl)
	// assert
	assert.NoError(t, err)
	assert.Equal(t, 35, gslb.Spec.Strategy.DNSTtlSeconds)
	assert.False(t, len(gslb.Spec.Strategy.Weight) == 0)
	assert.Equal(t, 15, gslb.Spec.Strategy.Weight["za"])
	assert.Equal(t, 25, gslb.Spec.Strategy.Weight["eu"])
	assert.Equal(t, 60, gslb.Spec.Strategy.Weight["us"])
	assert.Equal(t, 3, len(gslb.Spec.Strategy.Weight))
}

func TestResolveSpecWithoutFields(t *testing.T) {
	// arrange
	cl, gslb := getTestContext("./testdata/free_omitempty.yaml")
	resolver := NewDependencyResolver()
	// act
	err := resolver.ResolveGslbSpec(context.TODO(), gslb, cl)
	// assert
	assert.NoError(t, err)
	assert.Equal(t, predefinedStrategy.DNSTtlSeconds, gslb.Spec.Strategy.DNSTtlSeconds)
	assert.True(t, len(gslb.Spec.Strategy.Weight) == 0)
}

func TestResolveSpecWithEmptyFields(t *testing.T) {
	// arrange
	cl, gslb := getTestContext("./testdata/invalid_omitempty_empty.yaml")
	resolver := NewDependencyResolver()
	// act
	err := resolver.ResolveGslbSpec(context.TODO(), gslb, cl)
	// assert
	assert.NoError(t, err)
	assert.Equal(t, predefinedStrategy.DNSTtlSeconds, gslb.Spec.Strategy.DNSTtlSeconds)
}

func TestResolveSpecWithType(t *testing.T) {
	type test struct {
		strategy    string
		expectederr bool
	}
	tests := []test{
		{RoundRobinStrategy, false},
		{FailoverStrategy, false},
		{GeoStrategy, false},
		{"", true},
		{"123", true},
		{"roundrobin", true},
		{" ", true},
	}
	// arrange
	cl, gslb := getTestContext("./testdata/free_omitempty.yaml")
	resolver := NewDependencyResolver()
	// act
	for _, tt := range tests {
		t.Run(fmt.Sprintf("strategy_%s", tt.strategy), func(t *testing.T) {
			gslb.Spec.Strategy.Type = tt.strategy
			err := resolver.ResolveGslbSpec(context.TODO(), gslb, cl)
			// assert
			assert.True(t, (err != nil) == tt.expectederr)
		})
	}
}

func TestResolveSpecWithWeightCornerCases(t *testing.T) {
	tests := []struct {
		strategy string
		weight   map[string]int
		err      bool
		empty    bool
	}{
		{RoundRobinStrategy, map[string]int{"us": -20}, true, false},
		{RoundRobinStrategy, map[string]int{"za": 2}, false, false},
		{RoundRobinStrategy, map[string]int{"us": 1000}, false, false},
		{RoundRobinStrategy, map[string]int{"us": 0}, false, false},

		{GeoStrategy, map[string]int{"za": 20}, true, false},
		{GeoStrategy, map[string]int{"us": 0}, true, false},
		{GeoStrategy, map[string]int{}, false, true},
		{GeoStrategy, nil, false, true},

		{RoundRobinStrategy, map[string]int{}, false, true},
		{RoundRobinStrategy, map[string]int{"us-1": 100, "us-2": 0}, false, false},
		{RoundRobinStrategy, map[string]int{"us-1": 100, "us-2": 100}, false, false},
		{RoundRobinStrategy, map[string]int{"us-1": 10000, "us-2": 100}, true, false},
		{RoundRobinStrategy, map[string]int{"us-1": 0, "us-2": 0}, false, false},
		{RoundRobinStrategy, map[string]int{"us-1": 50, "eu": 20, "za": 0}, false, false},
	}
	// arrange
	cl, gslb := getTestContext("./testdata/filled_omitempty.yaml")
	resolver := NewDependencyResolver()
	// act
	for _, test := range tests {
		t.Run(fmt.Sprintf("weight_%s_%v", test.strategy, test.weight), func(t *testing.T) {
			gslb.Spec.Strategy.Weight = test.weight
			gslb.Spec.Strategy.Type = test.strategy
			err := resolver.ResolveGslbSpec(context.TODO(), gslb, cl)
			// assert
			assert.Equal(t, test.empty, len(gslb.Spec.Strategy.Weight) == 0)
			assert.True(t, (err != nil) == test.err)
		})
	}
}

func TestSpecRunWhenChanged(t *testing.T) {
	// arrange
	cl, gslb := getTestContext("./testdata/filled_omitempty.yaml")
	ctx := context.Background()
	resolver := NewDependencyResolver()
	// act
	err1 := resolver.ResolveGslbSpec(ctx, gslb, cl)
	err2 := resolver.ResolveGslbSpec(ctx, gslb, cl)
	// assert
	assert.NoError(t, err1)
	// err2 would not be empty
	assert.NoError(t, err2)
	assert.Equal(t, 35, gslb.Spec.Strategy.DNSTtlSeconds)
}

func TestResolveSpecWithNilClient(t *testing.T) {
	// arrange
	_, gslb := getTestContext("./testdata/filled_omitempty.yaml")
	resolver := NewDependencyResolver()
	// act
	err := resolver.ResolveGslbSpec(context.TODO(), gslb, nil)
	// assert
	assert.Error(t, err)
}

func TestResolveConfigWithNegativeReconcileRequeueSecondsKey(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.ReconcileRequeueSeconds = -1
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveConfigWithZeroReconcileRequeueSecondsKey(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.ReconcileRequeueSeconds = 0
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveConfigWithNegativeNSRecordTTL(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.NSRecordTTL = -1
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveConfigWithZeroReconcileNSRecordTTL(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.NSRecordTTL = 0
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

// remove this test once the deprecated key is no longer supported
func TestResolveConfigWithDeprecatedEdgeDNSServerKey(t *testing.T) {
	// arrange
	defer func() {
		cleanup()
		if os.Unsetenv(EdgeDNSServerKey) != nil {
			panic(fmt.Errorf("cleanup %s", EdgeDNSServerKey))
		}
	}()
	expected := predefinedConfig
	expected.fallbackEdgeDNSServerName = "dns.cloud.example.com"
	configureEnvVar(expected)
	_ = os.Setenv(EdgeDNSServerKey, "dns.cloud.example.com")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	depr := resolver.GetDeprecations()
	config.DelegationZones = nil
	// assert
	assert.NoError(t, err)
	assert.NotEmpty(t, depr)
	assert.Equal(t, expected, *config)
}

func TestResolveConfigWithMalformedEdgeDNSServersKey(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "dns1;dns2?")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not match given criteria")
}

func TestResolveConfigWithMalformedGeoTag(t *testing.T) {
	// arrange
	defer cleanup()
	for _, tag := range []string{"eu-west.1", "eu?", " ", "eu west1", "?/"} {
		expected := predefinedConfig
		expected.ClusterGeoTag = tag
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.Error)
	}
}

func TestResolveConfigWithProperGeoTag(t *testing.T) {
	// arrange
	defer cleanup()
	for _, tag := range []string{"eu-west-1", "eu-west1", "us", "1", "US"} {
		expected := predefinedConfig
		expected.ClusterGeoTag = tag
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.NoError)
	}
}

func TestConfigRunOnce(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	resolver := NewDependencyResolver()
	// act
	config1, err1 := resolver.ResolveOperatorConfig()
	config1.DelegationZones = nil
	depr1 := resolver.GetDeprecations()
	_ = os.Setenv(ReconcileRequeueSecondsKey, "100")
	// resolve again with new values
	config2, err2 := resolver.ResolveOperatorConfig()
	config2.DelegationZones = nil
	depr2 := resolver.GetDeprecations()
	// assert
	assert.NoError(t, err1)
	assert.Empty(t, depr1)
	assert.Equal(t, predefinedConfig, *config1)
	// config2, err2 would be equal
	assert.NoError(t, err2)
	assert.Empty(t, depr2)
	assert.Equal(t, *config1, *config2)
}

func TestResolveConfigWithEmptyEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils2.DNSServer{}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveConfigWithTwoEdgeDnsServers(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils2.DNSServer{
		{
			Host: "8.8.8.8",
			Port: 53,
		},
		{
			Host: "8.8.4.4",
			Port: 53,
		},
	}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveConfigWithNoEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils2.DNSServer{}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error, EdgeDNSServersKey)
}

func TestResolveConfigWithEmptyIpAddressInEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils2.DNSServer{
		{
			Host: defaultEdgeDNSServerIP,
			Port: 53,
		},
	}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveConfigWithHostnameEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils2.DNSServer{
		{
			Host: "server-nonprod.on.domain.l3.2l.com",
			Port: 53,
		},
	}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)

}

func TestResolveConfigWithInvalidIpAddressEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils2.DNSServer{
		{
			Host: fmt.Sprintf("%s.", defaultEdgeDNSServerIP),
			Port: 53,
		},
	}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveConfigWithMultipleEdgeDnsServers1(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1:53,  2.2.2.2:42")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	depr := resolver.GetDeprecations()
	// assert
	assert.NoError(t, err)
	assert.Empty(t, depr)
	assert.Equal(t, 2, len(config.EdgeDNSServers))
	assert.Equal(t, 42, config.EdgeDNSServers[1].Port)
}

func TestResolveConfigWithMultipleEdgeDnsServers2(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1:11, 2.2.2.2:22, 3.3.3.3, somedns:1337")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	depr := resolver.GetDeprecations()
	// assert
	assert.NoError(t, err)
	assert.Empty(t, depr)
	assert.Equal(t, 4, len(config.EdgeDNSServers))
	assert.Equal(t, "1.1.1.1", config.EdgeDNSServers[0].Host)
	assert.Equal(t, 11, config.EdgeDNSServers[0].Port)
	assert.Equal(t, 22, config.EdgeDNSServers[1].Port)
	assert.Equal(t, 53, config.EdgeDNSServers[2].Port)
	assert.Equal(t, 1337, config.EdgeDNSServers[3].Port)
	assert.Equal(t, "somedns", config.EdgeDNSServers[3].Host)
}

func TestResolveConfigWithNoEdgeDnsServerPort(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.NoError(t, err)
	assert.Equal(t, 53, config.EdgeDNSServers[0].Port)
}

func TestResolveConfigWithEdgeDnsServerPort(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1:42")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.NoError(t, err)
	assert.Equal(t, 42, config.EdgeDNSServers[0].Port)
}

func TestResolveConfigWithInvalidEdgeDnsServerPort1(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1:invalid")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not match given criteria")
}

func TestResolveConfigWithInvalidEdgeDnsServersValue(t *testing.T) {
	for _, invalid := range []string{"127.0.0.1:5 053", "host.cloud.example.com:5353:21", "1.2.3.:53", "1.2.3.4:5 3", "21:host.cloud.example.com",
		"1.2.3.4:3,,1.2.3.4:4", ",1.2.3.4:4", "1.2.3.4:4,", "host.cloud..example.com", "host.cloud example.com"} {
		// arrange
		defer cleanup()
		configureEnvVar(predefinedConfig)
		_ = os.Setenv(EdgeDNSServersKey, invalid)
		resolver := NewDependencyResolver()
		// act
		_, err := resolver.ResolveOperatorConfig()
		// assert
		assert.Error(t, err, fmt.Sprintf("Value %s should not pass the regexp check, but it did.", invalid))
		assert.True(t, strings.Contains(err.Error(), "does not match given criteria") || strings.Contains(err.Error(), "is empty"))
	}
}

func TestResolveConfigWithMultipleEdgeDnsServersLocalhostNotFirst(t *testing.T) {
	for _, invalid := range []string{"valid:53, 127.0.0.1:53", "127.0.0.1:5353, 127.0.0.1:53", "valid:53,valid:5353,localhost"} {
		// arrange
		defer cleanup()
		configureEnvVar(predefinedConfig)
		_ = os.Setenv(EdgeDNSServersKey, invalid)
		resolver := NewDependencyResolver()
		// act
		_, err := resolver.ResolveOperatorConfig()
		// assert
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "other than the first position")
	}
}

func TestResolveConfigWithMultipleEdgeDnsServersMalformed1(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "somehost:,somehost3:123:aaa.com")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not match given criteria")
}

func TestResolveConfigWithMultipleEdgeDnsServersMalformed2(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1,")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not match given criteria")
}

func TestResolveConfigWithInvalidHostnameEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "https://server-nonprod.on.domain.l3.2l.com")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not match given criteria")
}

func TestResolveConfigWithZeroOrNegativeEdgeDnsServerPort(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1:-53")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
}

func TestResolveConfigWithInvalidK8gbNamespace(t *testing.T) {
	// arrange
	defer cleanup()
	for _, ns := range []string{"-", "Op.", "kube/netes", "my-ns???", "123-MY", "MY-123"} {
		expected := predefinedConfig
		expected.K8gbNamespace = ns
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.Error)
	}
}

func TestResolveConfigWithValidK8gbNamespace(t *testing.T) {
	// arrange
	defer cleanup()
	for _, ns := range []string{"k8gb", "my-123", "123-my", "n"} {
		expected := predefinedConfig
		expected.K8gbNamespace = ns
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.NoError)
	}
}

func TestResolveMultipleExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.extClustersGeoTags = []string{"foo", "blah", "boom"}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveUnsetExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.extClustersGeoTags = []string{}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error, ExtClustersGeoTagsKey)
}

func TestResolveInvalidExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	for _, arr := range [][]string{{"good-tag", ".wrong.tag?"}, {"", ""}} {
		expected := predefinedConfig
		expected.extClustersGeoTags = arr
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.Error)
	}
}

func TestResolveOnlyGeoTagExistsWithinExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	tag := "us-west1"
	expected := predefinedConfig
	expected.ClusterGeoTag = tag
	expected.extClustersGeoTags = []string{}
	configureEnvVar(expected)
	os.Setenv(ExtClustersGeoTagsKey, tag)
	resolver := NewDependencyResolver()
	config, err := resolver.ResolveOperatorConfig()
	assert.Error(t, err)
	assert.Equal(t, expected, *config)
}

func TestResolveGeoTagExistsWithinExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	tag := "us-west1"
	for _, arr := range [][]string{{"good-tag"}, {"us-east1", "eu"}} {
		expected := predefinedConfig
		expected.ClusterGeoTag = tag
		expected.extClustersGeoTags = arr
		configureEnvVar(expected)
		os.Setenv(ExtClustersGeoTagsKey, strings.Join(append(arr, tag), ","))
		// act,assert
		resolver := NewDependencyResolver()
		// act
		config, err := resolver.ResolveOperatorConfig()
		config.DelegationZones = nil
		// assert
		assert.NoError(t, err)
		assert.Equal(t, expected, *config)
	}
}

func TestResolveGeoTagWithRepeatingExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.extClustersGeoTags = []string{"foo", "blah", "foo"}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestBothRoute53AndInfobloxAreEnabled(t *testing.T) {
	// arrange
	defer cleanup()
	customConfig := predefinedConfig
	customConfig.Infoblox.Host = "Infoblox.domain"
	customConfig.Infoblox.Version = "0.0.1"
	customConfig.Infoblox.Port = 443
	customConfig.Infoblox.Username = defaultInfobloxUsername
	customConfig.Infoblox.Password = defaultInfobloxPassword
	configureEnvVar(customConfig)
	_ = os.Setenv(ExtDNSEnabledKey, "true")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Equal(t, DNSTypeMultipleProviders, config.EdgeDNSType)
}

func TestRoute53NS1AndInfobloxAreConfigured(t *testing.T) {
	// arrange
	defer cleanup()
	// predefinedConfig has Infoblox preconfigured
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(ExtDNSEnabledKey, "true")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	recognizedEdgeDNSType, recognizedEdgeDNSTypes := getEdgeDNSType(config)
	// assert
	assert.Error(t, err)
	assert.Equal(t, DNSTypeMultipleProviders, config.EdgeDNSType)
	assert.Equal(t, recognizedEdgeDNSType, config.EdgeDNSType)
	assert.Equal(t, recognizedEdgeDNSTypes, []EdgeDNSType{DNSTypeExternal, DNSTypeInfoblox})
}

func TestNoDNSIsConfigured(t *testing.T) {
	// arrange
	defer cleanup()
	customConfig := predefinedConfig
	customConfig.Infoblox.Host = ""
	configureEnvVar(customConfig)
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	recognizedEdgeDNSType, recognizedEdgeDNSTypes := getEdgeDNSType(config)
	// assert
	assert.NoError(t, err)
	assert.Equal(t, DNSTypeNoEdgeDNS, config.EdgeDNSType)
	assert.Equal(t, recognizedEdgeDNSType, config.EdgeDNSType)
	assert.Equal(t, recognizedEdgeDNSTypes, []EdgeDNSType{})
}

func TestRoute53IsDisabledAndInfobloxIsNotConfigured(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeNoEdgeDNS
	expected.extDNSEnabled = false
	expected.Infoblox.Host = ""
	// act,assert
	// that's how our integration tests are running
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestRoute53IsDisabledButInfobloxIsConfigured(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.extDNSEnabled = false
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = "Infoblox.domain"
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestRoute53IsEnabledButInfobloxIsNotConfigured(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.extDNSEnabled = true
	expected.EdgeDNSType = DNSTypeExternal
	expected.Infoblox.Host = ""
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestInfobloxGridHostIsEmpty(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeExternal
	expected.extDNSEnabled = true
	expected.Infoblox.Host = ""
	expected.Infoblox.Version = ""
	expected.Infoblox.Port = 0
	expected.Infoblox.Username = ""
	expected.Infoblox.Password = ""
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestInfobloxGridHostIsNotEmpty(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = defaultHost
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestInfobloxGridHostIsNotEmptyButInfobloxPropsAreEmpty(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = defaultHost
	expected.Infoblox.Version = ""
	expected.Infoblox.Port = 0
	expected.Infoblox.Username = ""
	expected.Infoblox.Password = ""
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestInfobloxGridHostIsEmptyButInfobloxPropsAreFilled(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeExternal
	expected.extDNSEnabled = true
	expected.Infoblox.Host = ""
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestInfobloxGridHostIsUnset(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeNoEdgeDNS
	expected.extDNSEnabled = false
	expected.Infoblox.Host = ""
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	// values are ignored and not validated
	arrangeVariablesAndAssert(t, expected, assert.NoError, InfobloxGridHostKey)
}

func TestInfobloxGridHostIsInvalid(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.extDNSEnabled = false
	expected.Infoblox.Host = "dnfkjdnf kj"
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestInfobloxVersionIsValid(t *testing.T) {
	// arrange
	defer cleanup()
	// version can be empty!
	for _, v := range []string{"0.0.1", "v0.0.1", "v0.0.0-patch1", "2.3.5-patch1"} {
		expected := predefinedConfig
		expected.EdgeDNSType = DNSTypeInfoblox
		expected.Infoblox.Host = defaultHost
		expected.Infoblox.Version = v
		expected.Infoblox.Port = 443
		expected.Infoblox.Username = defaultInfobloxUsername
		expected.Infoblox.Password = defaultInfobloxPassword
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.NoError)
	}
}

func TestInfobloxVersionIsInvalid(t *testing.T) {
	// arrange
	defer cleanup()
	for _, v := range []string{"0.1.*", "kkojo", "k12k", ""} {
		expected := predefinedConfig
		expected.EdgeDNSType = DNSTypeInfoblox
		expected.Infoblox.Host = defaultHost
		expected.Infoblox.Version = v
		expected.Infoblox.Port = 443
		expected.Infoblox.Username = defaultInfobloxUsername
		expected.Infoblox.Password = defaultInfobloxPassword
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.Error)
	}
}

func TestInvalidInfobloxPort(t *testing.T) {
	// arrange
	defer cleanup()
	for _, p := range []int{-1, 0, 65536} {
		expected := predefinedConfig
		expected.EdgeDNSType = DNSTypeInfoblox
		expected.Infoblox.Host = defaultHost
		expected.Infoblox.Version = defaultVersion
		expected.Infoblox.Port = p
		expected.Infoblox.Username = defaultInfobloxUsername
		expected.Infoblox.Password = defaultInfobloxPassword
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.Error)
	}
}

func TestValidInfobloxUserPasswordAndPort(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = defaultHost
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = "infobloxUser"
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestEmptyInfobloxUser(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = defaultHost
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = ""
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestEmptyInfobloxPassword(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = defaultHost
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = "infobloxUser"
	expected.Infoblox.Password = ""
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestValidInfobloxHTTPPoolConnections(t *testing.T) {
	// arrange
	defer cleanup()
	// act,assert
	arrangeVariablesAndAssert(t, predefinedConfig, assert.NoError)
}

func TestInvalidInfobloxHTTPPoolConnections(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(InfobloxHTTPPoolConnectionsKey, "i.am.wrong??.")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
}

func TestZeroInfobloxHTTPPoolConnections(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Infoblox.HTTPPoolConnections = 0
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestNegativeInfobloxHTTPPoolConnections(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Infoblox.HTTPPoolConnections = -1
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestValidInfobloxHTTPRequestTimeout(t *testing.T) {
	// arrange
	defer cleanup()
	// act,assert
	arrangeVariablesAndAssert(t, predefinedConfig, assert.NoError)
}

func TestZeroInfobloxHTTPRequestTimeout(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Infoblox.HTTPRequestTimeout = 0
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestNegativeInfobloxHTTPRequestTimeout(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Infoblox.HTTPRequestTimeout = -1
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveLoggerUseDefaultValue(t *testing.T) {
	// arrange
	// Build zerolog from empty string which is equal to zerolog.NoLevel.
	// Depresolver handles it "" and use default value - info level
	defer cleanup()
	expected := predefinedConfig
	expected.Log.Level = zerolog.InfoLevel
	expected.Log.level = zerolog.InfoLevel.String()
	expected.Log.NoColor = false
	// act
	// assert
	arrangeVariablesAndAssert(t, expected, assert.NoError, LogLevelKey, LogFormatKey, LogNoColorKey)
}

func TestResolveLoggerOutputFormatMode(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Log.Format = SimpleFormat
	expected.Log.Level = zerolog.InfoLevel
	expected.Log.level = zerolog.InfoLevel.String()
	// act
	// assert
	arrangeVariablesAndAssert(t, expected, assert.NoError, LogLevelKey)
}

func TestResolveLoggerDebugMode(t *testing.T) {
	// arrange
	expected := predefinedConfig
	expected.Log.Level = zerolog.DebugLevel
	// act
	// assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveLoggerNoColor(t *testing.T) {
	// arrange
	expected := predefinedConfig
	expected.Log.NoColor = true
	// act
	// assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveLoggerInfoMode(t *testing.T) {
	// arrange
	expected := predefinedConfig
	expected.Log.Level = zerolog.InfoLevel
	expected.Log.level = zerolog.InfoLevel.String()
	// act
	// assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveLoggerCaseInsensitiveMode(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(LogLevelKey, "WARn")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.NoError(t, err)
	assert.Equal(t, zerolog.WarnLevel, config.Log.Level)
}

func TestResolveLoggerCaseInsensitiveOutputFormat(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(LogFormatKey, "Json")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.NoError(t, err)
	assert.Equal(t, JSONFormat, config.Log.Format)
}

func TestResolveLoggerLevelWithInvalidValue(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(LogLevelKey, "i.am.wrong??.")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Equal(t, zerolog.NoLevel, config.Log.Level)
	assert.Equal(t, SimpleFormat, config.Log.Format)
}

func TestResolveLoggerOutputWithInvalidValue(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(LogFormatKey, "i.am.wrong??.")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Equal(t, NoFormat, config.Log.Format)
}

func TestMetricsAddressIsValid(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.0:9091"
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestMetricsAddressPortLimitExceed(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.0:80091"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressPortLimitUnder(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.0:1024"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressInvalidPort(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.0:808x"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressInvalidHost(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "x.y.z??:8080"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressWrongFormatMultipleParts(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.0:8080:9090"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressWrongFormatSinglePart(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.08080"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressInvalidEnvVariable(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "invalid"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressEmptyHost(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = ":8080"
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestMetricsAddressWithValidHostName(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "address.com:8080"
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

// arrangeVariablesAndAssert sets string environment variables and asserts `expected` argument with
// ResolveOperatorConfig() output. The last parameter unsets the values
func arrangeVariablesAndAssert(t *testing.T, expected Config,
	errf func(t assert.TestingT, err error, msgAndArgs ...interface{}) bool, unset ...string) {
	configureEnvVar(expected)
	for _, v := range unset {
		_ = os.Unsetenv(v)
	}
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	if config == nil {
		t.Fatal("nil *config returned")
	}
	config.DelegationZones = nil
	assert.Equal(t, expected, *config)
	errf(t, err)
}

func cleanup() {
	for _, s := range []string{ReconcileRequeueSecondsKey, NSRecordTTLKey, ClusterGeoTagKey, ExtClustersGeoTagsKey,
		EdgeDNSServersKey, ExtDNSEnabledKey, InfobloxGridHostKey, InfobloxVersionKey, InfobloxPortKey, InfobloxUsernameKey,
		InfobloxPasswordKey, K8gbNamespaceKey, CoreDNSExposedKey, InfobloxHTTPRequestTimeoutKey, CoreDNSServiceTypeKey,
		InfobloxHTTPPoolConnectionsKey, LogLevelKey, LogFormatKey, LogNoColorKey, MetricsAddressKey, TracingEnabled,
		TracingSamplingRatio, OtelExporterOtlpEndpoint, DNSZonesKey} {
		if os.Unsetenv(s) != nil {
			panic(fmt.Errorf("cleanup %s", s))
		}
	}
}

func configureEnvVar(config Config) {
	_ = os.Unsetenv(EdgeDNSServerKey)
	_ = os.Unsetenv(EdgeDNSServerPortKey)
	_ = os.Setenv(ReconcileRequeueSecondsKey, strconv.Itoa(config.ReconcileRequeueSeconds))
	_ = os.Setenv(NSRecordTTLKey, strconv.Itoa(config.NSRecordTTL))
	_ = os.Setenv(ClusterGeoTagKey, config.ClusterGeoTag)
	_ = os.Setenv(ExtClustersGeoTagsKey, strings.Join(config.extClustersGeoTags, ","))
	_ = os.Setenv(EdgeDNSServersKey, config.EdgeDNSServers.String())
	_ = os.Setenv(K8gbNamespaceKey, config.K8gbNamespace)
	_ = os.Setenv(ExtDNSEnabledKey, strconv.FormatBool(config.extDNSEnabled))
	_ = os.Setenv(CoreDNSExposedKey, strconv.FormatBool(config.CoreDNSExposed))
	_ = os.Setenv(InfobloxGridHostKey, config.Infoblox.Host)
	_ = os.Setenv(InfobloxVersionKey, config.Infoblox.Version)
	_ = os.Setenv(InfobloxPortKey, strconv.Itoa(config.Infoblox.Port))
	_ = os.Setenv(InfobloxUsernameKey, config.Infoblox.Username)
	_ = os.Setenv(InfobloxPasswordKey, config.Infoblox.Password)
	_ = os.Setenv(InfobloxHTTPRequestTimeoutKey, strconv.Itoa(config.Infoblox.HTTPRequestTimeout))
	_ = os.Setenv(InfobloxHTTPPoolConnectionsKey, strconv.Itoa(config.Infoblox.HTTPPoolConnections))
	_ = os.Setenv(LogLevelKey, config.Log.Level.String())
	_ = os.Setenv(LogFormatKey, config.Log.Format.String())
	_ = os.Setenv(LogNoColorKey, strconv.FormatBool(config.Log.NoColor))
	_ = os.Setenv(MetricsAddressKey, config.MetricsAddress)
	_ = os.Setenv(TracingEnabled, strconv.FormatBool(config.TracingEnabled))
	_ = os.Setenv(TracingSamplingRatio, strconv.FormatFloat(config.TracingSamplingRatio, 'f', 2, 64))
	_ = os.Setenv(OtelExporterOtlpEndpoint, config.OtelExporterOtlpEndpoint)
	_ = os.Setenv(DNSZonesKey, config.dnsZones)
	_ = os.Setenv(CoreDNSServiceTypeKey, config.CoreDNSServiceType)
}

func getTestContext(testData string) (client.Client, *k8gbv1beta1.Gslb) {
	// Create a fake client to mock API calls.
	var gslbYaml, err = os.ReadFile(testData)
	if err != nil {
		panic(fmt.Errorf("can't open example CR file: %s", testData))
	}
	gslb, err := utils2.YamlToGslb(gslbYaml)
	if err != nil {
		panic(err)
	}
	objs := []runtime.Object{
		gslb,
	}
	// Register operator types with the runtime scheme.
	s := scheme.Scheme
	s.AddKnownTypes(k8gbv1beta1.GroupVersion, gslb)
	// Register external-dns DNSEndpoint CRD
	s.AddKnownTypes(schema.GroupVersion{Group: "externaldns.k8s.io", Version: "v1alpha1"}, &externaldns.DNSEndpoint{})
	cl := fake.NewClientBuilder().WithScheme(s).WithRuntimeObjects(objs...).Build()
	return cl, gslb
}

//nolint:goconst
func TestParseDNSZones(t *testing.T) {
	str220 := `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1.
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb2.
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc3.eee`
	str64 := "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1"

	contains := func(dzi []*DelegationZoneInfo, compare func(info *DelegationZoneInfo) bool) bool {
		for _, v := range dzi {
			if compare(v) {
				return true
			}
		}
		return false
	}
	tests := []struct {
		name        string
		expectedLen int
		config      *Config
		assert      func(zoneInfo []*DelegationZoneInfo, err error)
	}{
		{
			name: "invalid negTTL",
			config: &Config{
				dnsZones:           "example.com:cloud.example.com:30x",
				EdgeDNSServers:     []utils2.DNSServer{{Host: "edge.com", Port: 53}},
				ClusterGeoTag:      "us",
				extClustersGeoTags: []string{"za", "eu"},
			},
			expectedLen: 0,
			assert: func(_ []*DelegationZoneInfo, err error) {
				assert.Error(t, err)
			},
		},
		{
			name: "multiple zones",
			config: &Config{
				dnsZones:           "example.com:cloud.example.com:30;example.io:cloud.example.io:50",
				EdgeDNSServers:     []utils2.DNSServer{{Host: "edge.com", Port: 53}},
				ClusterGeoTag:      "us",
				extClustersGeoTags: []string{"za", "eu"},
			},
			expectedLen: 2,
			assert: func(zoneInfo []*DelegationZoneInfo, err error) {
				assert.NoError(t, err)
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ParentZone == "example.com" && info.Zone == "cloud.example.com"
				}))
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ParentZone == "example.io" && info.Zone == "cloud.example.io"
				}))
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ClusterNSName == "gslb-ns-us-cloud.example.com" &&
						info.GetNSServerList()[0] == "gslb-ns-eu-cloud.example.com" &&
						info.GetNSServerList()[1] == "gslb-ns-us-cloud.example.com" &&
						info.GetNSServerList()[2] == "gslb-ns-za-cloud.example.com" &&
						info.GetExternalDNSEndpointName() == "k8gb-ns-extdns-cloud-example-com"
				}))
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ClusterNSName == "gslb-ns-us-cloud.example.io" &&
						info.GetNSServerList()[0] == "gslb-ns-eu-cloud.example.io" &&
						info.GetNSServerList()[1] == "gslb-ns-us-cloud.example.io" &&
						info.GetNSServerList()[2] == "gslb-ns-za-cloud.example.io" &&
						info.GetExternalDNSEndpointName() == "k8gb-ns-extdns-cloud-example-io"
				}))
			},
		},
		{
			name: "multiple domains",
			config: &Config{
				dnsZones:           "example.com:cloud.example.com:30;example.com:pair.example.com:50",
				EdgeDNSServers:     []utils2.DNSServer{{Host: "edge.com", Port: 53}},
				ClusterGeoTag:      "us",
				extClustersGeoTags: []string{"za", "eu"},
			},
			expectedLen: 2,
			assert: func(zoneInfo []*DelegationZoneInfo, err error) {
				assert.NoError(t, err)
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ParentZone == "example.com" && info.Zone == "cloud.example.com"
				}))
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ParentZone == "example.com" && info.Zone == "pair.example.com"
				}))
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ClusterNSName == "gslb-ns-us-cloud.example.com" &&
						info.GetNSServerList()[0] == "gslb-ns-eu-cloud.example.com" &&
						info.GetNSServerList()[1] == "gslb-ns-us-cloud.example.com" &&
						info.GetNSServerList()[2] == "gslb-ns-za-cloud.example.com" &&
						info.GetExternalDNSEndpointName() == "k8gb-ns-extdns-cloud-example-com"
				}))
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ClusterNSName == "gslb-ns-us-pair.example.com" &&
						info.GetNSServerList()[0] == "gslb-ns-eu-pair.example.com" &&
						info.GetNSServerList()[1] == "gslb-ns-us-pair.example.com" &&
						info.GetNSServerList()[2] == "gslb-ns-za-pair.example.com" &&
						info.GetExternalDNSEndpointName() == "k8gb-ns-extdns-pair-example-com"
				}))
			},
		},
		{
			name: "ends with semicolon",
			config: &Config{
				dnsZones:           "example.com:cloud.example.com:30;example.io:cloud.example.io:300;",
				EdgeDNSServers:     []utils2.DNSServer{{Host: "edge.com", Port: 53}},
				ClusterGeoTag:      "us",
				extClustersGeoTags: []string{"za", "eu"},
			},
			expectedLen: 2,
			assert: func(zoneInfo []*DelegationZoneInfo, err error) {
				assert.NoError(t, err)
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ParentZone == "example.com" && info.Zone == "cloud.example.com"
				}))
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ParentZone == "example.io" && info.Zone == "cloud.example.io"
				}))
			},
		},
		{
			name: "trimmed spaces and semicolons",
			config: &Config{
				dnsZones:           "example.com: cloud.example.com: 50; example.io:cloud.example.io: 30 ;",
				EdgeDNSServers:     []utils2.DNSServer{{Host: "edge.com", Port: 53}},
				ClusterGeoTag:      "us",
				extClustersGeoTags: []string{"za", "eu"},
			},
			expectedLen: 2,
			assert: func(zoneInfo []*DelegationZoneInfo, err error) {
				assert.NoError(t, err)
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ParentZone == "example.com" && info.Zone == "cloud.example.com"
				}))
				assert.True(t, contains(zoneInfo, func(info *DelegationZoneInfo) bool {
					return info.ParentZone == "example.io" && info.Zone == "cloud.example.io"
				}))
			},
		},
		{
			name: "check nsNames",
			config: &Config{
				dnsZones:           "cloud.example.com: k8gb-test.gslb.cloud.example.com :60;",
				EdgeDNSServers:     []utils2.DNSServer{{Host: "edge.com", Port: 53}},
				ClusterGeoTag:      "us",
				extClustersGeoTags: []string{"za", "eu"},
			},
			expectedLen: 1,
			assert: func(zoneInfo []*DelegationZoneInfo, err error) {
				assert.NoError(t, err)
				assert.True(t, zoneInfo[0].ClusterNSName == "gslb-ns-us-k8gb-test-gslb.cloud.example.com" &&
					zoneInfo[0].ExtClusterNSNames["za"] == "gslb-ns-za-k8gb-test-gslb.cloud.example.com" &&
					zoneInfo[0].ExtClusterNSNames["eu"] == "gslb-ns-eu-k8gb-test-gslb.cloud.example.com")
			},
		},

		{
			name: "nsName exceed exceed limit 253 characters",
			config: &Config{
				dnsZones:           fmt.Sprintf("cloud.example.com:k8gb-test.%s.gslb.cloud.example.com:60;", str220),
				EdgeDNSServers:     []utils2.DNSServer{{Host: "edge.com", Port: 53}},
				ClusterGeoTag:      "us",
				extClustersGeoTags: []string{"za", "eu"},
			},
			expectedLen: 1,
			assert: func(_ []*DelegationZoneInfo, err error) {
				assert.Error(t, err)
			},
		},
		{
			name: "nsName label exceed limit 63 characters",
			config: &Config{
				dnsZones:           fmt.Sprintf("cloud.example.com: %s.gslb.cloud.example.com:60;", str64),
				EdgeDNSServers:     []utils2.DNSServer{{Host: "edge.com", Port: 53}},
				ClusterGeoTag:      "us",
				extClustersGeoTags: []string{"za", "eu"},
			},
			expectedLen: 1,
			assert: func(_ []*DelegationZoneInfo, err error) {
				assert.Error(t, err)
			},
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			zoneInfo, err := parseDelegationZones(test.config)
			test.assert(zoneInfo, err)
			assert.Equal(t, test.expectedLen, len(zoneInfo))
		})
	}
}
