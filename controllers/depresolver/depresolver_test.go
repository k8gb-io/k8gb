package depresolver

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"strconv"
	"strings"
	"testing"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	"github.com/k8gb-io/k8gb/controllers/internal/utils"

	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/kubernetes/scheme"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
	externaldns "sigs.k8s.io/external-dns/endpoint"
)

const (
	defaultDNSZone          = "k8gb-test-preprod.gslb.cloud.example.com"
	defaultEdgeDNSZone      = "cloud.example.com"
	defaultVersion          = "0.0.1"
	defaultHost             = "test.domain"
	defaultInfobloxUsername = "foo"
	defaultInfobloxPassword = "blah"
	defaultClusterGeoTagUs1 = "us-west-1"
	defaultClusterGeoTagUs2 = "us-east-1"
	defaultClusterGeoTagEu  = "eu-central-1"
	defaultEdgeDNSServerIP  = "10.0.40.2"
)

var predefinedConfig = Config{
	ReconcileRequeueSeconds: 30,
	ClusterGeoTag:           "us",
	ExtClustersGeoTags:      []string{"za", "eu"},
	EdgeDNSType:             DNSTypeInfoblox,
	EdgeDNSServers: []utils.DNSServer{
		{
			Host: "dns.cloud.example.com",
			Port: 53,
		},
	},
	fallbackEdgeDNSServerName: "",
	fallbackEdgeDNSServerPort: 53,
	EdgeDNSZone:               "example.com",
	DNSZone:                   defaultEdgeDNSZone,
	K8gbNamespace:             "k8gb",
	SplitBrainCheck:           true,
	MetricsAddress:            "0.0.0.0:8080",
	Infoblox: Infoblox{
		"Infoblox.host.com",
		"0.0.3",
		443,
		"Infoblox",
		"secret",
		21,
		11,
	},
	Log: Log{
		Format: SimpleFormat,
		format: SimpleFormat.String(),
		level:  zerolog.DebugLevel.String(),
	},
}

func TestResolveSpecWithFilledFields(t *testing.T) {
	// arrange
	cl, gslb := getTestContext("./testdata/filled_omitempty.yaml")
	resolver := NewDependencyResolver()
	// act
	err := resolver.ResolveGslbSpec(context.TODO(), gslb, cl)
	// assert
	assert.NoError(t, err)
	assert.Equal(t, 35, gslb.Spec.Strategy.DNSTtlSeconds)
	assert.Equal(t, 305, gslb.Spec.Strategy.SplitBrainThresholdSeconds)
}

func TestResolveSpecWithoutFields(t *testing.T) {
	// arrange
	cl, gslb := getTestContext("./testdata/free_omitempty.yaml")
	resolver := NewDependencyResolver()
	// act
	err := resolver.ResolveGslbSpec(context.TODO(), gslb, cl)
	// assert
	assert.NoError(t, err)
	assert.Equal(t, predefinedStrategy.DNSTtlSeconds, gslb.Spec.Strategy.DNSTtlSeconds)
	assert.Equal(t, predefinedStrategy.SplitBrainThresholdSeconds, gslb.Spec.Strategy.SplitBrainThresholdSeconds)
}

func TestResolveSpecWithZeroSplitBrain(t *testing.T) {
	// arrange
	cl, gslb := getTestContext("./testdata/filled_omitempty_with_zero_splitbrain.yaml")
	resolver := NewDependencyResolver()
	// act
	err := resolver.ResolveGslbSpec(context.TODO(), gslb, cl)
	// assert
	assert.NoError(t, err)
	assert.Equal(t, 35, gslb.Spec.Strategy.DNSTtlSeconds)
	assert.Equal(t, predefinedStrategy.SplitBrainThresholdSeconds, gslb.Spec.Strategy.SplitBrainThresholdSeconds)
}

func TestResolveSpecWithEmptyFields(t *testing.T) {
	// arrange
	cl, gslb := getTestContext("./testdata/invalid_omitempty_empty.yaml")
	resolver := NewDependencyResolver()
	// act
	err := resolver.ResolveGslbSpec(context.TODO(), gslb, cl)
	// assert
	assert.NoError(t, err)
	assert.Equal(t, predefinedStrategy.DNSTtlSeconds, gslb.Spec.Strategy.DNSTtlSeconds)
	assert.Equal(t, predefinedStrategy.SplitBrainThresholdSeconds, gslb.Spec.Strategy.SplitBrainThresholdSeconds)
}

func TestResolveSpecWithNegativeFields(t *testing.T) {
	// arrange
	cl, gslb := getTestContext("./testdata/invalid_omitempty_negative.yaml")
	resolver := NewDependencyResolver()
	// act
	err := resolver.ResolveGslbSpec(context.TODO(), gslb, cl)
	// assert
	assert.Error(t, err)
}

func TestSpecRunWhenChanged(t *testing.T) {
	// arrange
	cl, gslb := getTestContext("./testdata/filled_omitempty.yaml")
	ctx := context.Background()
	resolver := NewDependencyResolver()
	// act
	err1 := resolver.ResolveGslbSpec(ctx, gslb, cl)
	gslb.Spec.Strategy.SplitBrainThresholdSeconds = 0
	err2 := resolver.ResolveGslbSpec(ctx, gslb, cl)
	// assert
	assert.NoError(t, err1)
	// err2 would not be empty
	assert.NoError(t, err2)
	assert.Equal(t, predefinedStrategy.SplitBrainThresholdSeconds, gslb.Spec.Strategy.SplitBrainThresholdSeconds)
	assert.Equal(t, 35, gslb.Spec.Strategy.DNSTtlSeconds)
}

func TestResolveSpecWithNilClient(t *testing.T) {
	// arrange
	_, gslb := getTestContext("./testdata/filled_omitempty.yaml")
	resolver := NewDependencyResolver()
	// act
	err := resolver.ResolveGslbSpec(context.TODO(), gslb, nil)
	// assert
	assert.Error(t, err)
}

func TestResolveConfigWithNegativeReconcileRequeueSecondsKey(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.ReconcileRequeueSeconds = -1
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveConfigWithZeroReconcileRequeueSecondsKey(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.ReconcileRequeueSeconds = 0
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

// remove this test once the deprecated key is no longer supported
func TestResolveConfigWithDeprecatedEdgeDNSServerKey(t *testing.T) {
	// arrange
	defer func() {
		cleanup()
		if os.Unsetenv(EdgeDNSServerKey) != nil {
			panic(fmt.Errorf("cleanup %s", EdgeDNSServerKey))
		}
	}()
	expected := predefinedConfig
	expected.fallbackEdgeDNSServerName = "dns.cloud.example.com"
	configureEnvVar(expected)
	_ = os.Setenv(EdgeDNSServerKey, "dns.cloud.example.com")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	depr := resolver.GetDeprecations()
	// assert
	assert.NoError(t, err)
	assert.NotEmpty(t, depr)
	assert.Equal(t, expected, *config)
}

func TestResolveConfigWithMalformedEdgeDNSServersKey(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "dns1;dns2?")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not match given criteria")
}

func TestResolveConfigWithMalformedGeoTag(t *testing.T) {
	// arrange
	defer cleanup()
	for _, tag := range []string{"eu-west.1", "eu?", " ", "eu west1", "?/"} {
		expected := predefinedConfig
		expected.ClusterGeoTag = tag
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.Error)
	}
}

func TestResolveConfigWithProperGeoTag(t *testing.T) {
	// arrange
	defer cleanup()
	for _, tag := range []string{"eu-west-1", "eu-west1", "us", "1", "US"} {
		expected := predefinedConfig
		expected.ClusterGeoTag = tag
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.NoError)
	}
}

func TestConfigRunOnce(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	resolver := NewDependencyResolver()
	// act
	config1, err1 := resolver.ResolveOperatorConfig()
	depr1 := resolver.GetDeprecations()
	_ = os.Setenv(ReconcileRequeueSecondsKey, "100")
	// resolve again with new values
	config2, err2 := resolver.ResolveOperatorConfig()
	depr2 := resolver.GetDeprecations()
	// assert
	assert.NoError(t, err1)
	assert.Empty(t, depr1)
	assert.Equal(t, predefinedConfig, *config1)
	// config2, err2 would be equal
	assert.NoError(t, err2)
	assert.Empty(t, depr2)
	assert.Equal(t, *config1, *config2)
}

func TestResolveConfigWithEmptyEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils.DNSServer{}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveConfigWithTwoEdgeDnsServers(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils.DNSServer{
		{
			Host: "8.8.8.8",
			Port: 53,
		},
		{
			Host: "8.8.4.4",
			Port: 53,
		},
	}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveConfigWithNoEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils.DNSServer{}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error, EdgeDNSServersKey)
}

func TestResolveConfigWithEmptyIpAddressInEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils.DNSServer{
		{
			Host: defaultEdgeDNSServerIP,
			Port: 53,
		},
	}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveConfigWithHostnameEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils.DNSServer{
		{
			Host: "server-nonprod.on.domain.l3.2l.com",
			Port: 53,
		},
	}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)

}

func TestResolveConfigWithInvalidIpAddressEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSServers = []utils.DNSServer{
		{
			Host: fmt.Sprintf("%s.", defaultEdgeDNSServerIP),
			Port: 53,
		},
	}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveConfigWithMultipleEdgeDnsServers1(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1:53,  2.2.2.2:42")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	depr := resolver.GetDeprecations()
	// assert
	assert.NoError(t, err)
	assert.Empty(t, depr)
	assert.Equal(t, 2, len(config.EdgeDNSServers))
	assert.Equal(t, 42, config.EdgeDNSServers[1].Port)
}

func TestResolveConfigWithMultipleEdgeDnsServers2(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1:11, 2.2.2.2:22, 3.3.3.3, somedns:1337")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	depr := resolver.GetDeprecations()
	// assert
	assert.NoError(t, err)
	assert.Empty(t, depr)
	assert.Equal(t, 4, len(config.EdgeDNSServers))
	assert.Equal(t, "1.1.1.1", config.EdgeDNSServers[0].Host)
	assert.Equal(t, 11, config.EdgeDNSServers[0].Port)
	assert.Equal(t, 22, config.EdgeDNSServers[1].Port)
	assert.Equal(t, 53, config.EdgeDNSServers[2].Port)
	assert.Equal(t, 1337, config.EdgeDNSServers[3].Port)
	assert.Equal(t, "somedns", config.EdgeDNSServers[3].Host)
}

func TestResolveConfigWithNoEdgeDnsServerPort(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.NoError(t, err)
	assert.Equal(t, 53, config.EdgeDNSServers[0].Port)
}

func TestResolveConfigWithEdgeDnsServerPort(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1:42")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.NoError(t, err)
	assert.Equal(t, 42, config.EdgeDNSServers[0].Port)
}

func TestResolveConfigWithInvalidEdgeDnsServerPort1(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1:invalid")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not match given criteria")
}

func TestResolveConfigWithInvalidEdgeDnsServersValue(t *testing.T) {
	for _, invalid := range []string{"127.0.0.1:5 053", "host.cloud.example.com:5353:21", "1.2.3.:53", "1.2.3.4:5 3", "21:host.cloud.example.com",
		"1.2.3.4:3,,1.2.3.4:4", ",1.2.3.4:4", "1.2.3.4:4,", "host.cloud..example.com", "host.cloud example.com"} {
		// arrange
		defer cleanup()
		configureEnvVar(predefinedConfig)
		_ = os.Setenv(EdgeDNSServersKey, invalid)
		resolver := NewDependencyResolver()
		// act
		_, err := resolver.ResolveOperatorConfig()
		// assert
		assert.Error(t, err, fmt.Sprintf("Value %s should not pass the regexp check, but it did.", invalid))
		assert.True(t, strings.Contains(err.Error(), "does not match given criteria") || strings.Contains(err.Error(), "is empty"))
	}
}

func TestResolveConfigWithMultipleEdgeDnsServersLocalhostNotFirst(t *testing.T) {
	for _, invalid := range []string{"valid:53, 127.0.0.1:53", "127.0.0.1:5353, 127.0.0.1:53", "valid:53,valid:5353,localhost"} {
		// arrange
		defer cleanup()
		configureEnvVar(predefinedConfig)
		_ = os.Setenv(EdgeDNSServersKey, invalid)
		resolver := NewDependencyResolver()
		// act
		_, err := resolver.ResolveOperatorConfig()
		// assert
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "other than the first position")
	}
}

func TestResolveConfigWithMultipleEdgeDnsServersMalformed1(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "somehost:,somehost3:123:aaa.com")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not match given criteria")
}

func TestResolveConfigWithMultipleEdgeDnsServersMalformed2(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1,")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not match given criteria")
}

func TestResolveConfigWithInvalidHostnameEdgeDnsServer(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "https://server-nonprod.on.domain.l3.2l.com")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not match given criteria")
}

func TestResolveConfigWithZeroOrNegativeEdgeDnsServerPort(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(EdgeDNSServersKey, "1.1.1.1:-53")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
}

func TestResolveConfigWithEmptyEdgeDnsZone(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSZone = ""
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveConfigWithHostnameEdgeDnsZone(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSZone = "company.2l.com"
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveConfigWithInvalidHostnameEdgeDnsZone(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSZone = "https://zone.com"
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveConfigWithInvalidHostnameDnsZone(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.DNSZone = "dns-zo?ne"
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveConfigWithInvalidK8gbNamespace(t *testing.T) {
	// arrange
	defer cleanup()
	for _, ns := range []string{"-", "Op.", "kube/netes", "my-ns???", "123-MY", "MY-123"} {
		expected := predefinedConfig
		expected.K8gbNamespace = ns
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.Error)
	}
}

func TestResolveConfigWithValidK8gbNamespace(t *testing.T) {
	// arrange
	defer cleanup()
	for _, ns := range []string{"k8gb", "my-123", "123-my", "n"} {
		expected := predefinedConfig
		expected.K8gbNamespace = ns
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.NoError)
	}
}

func TestResolveEmptyExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.DNSZone = ""
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error, DNSZoneKey)
}

func TestResolveMultipleExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.ExtClustersGeoTags = []string{"foo", "blah", "boom"}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveUnsetExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.ExtClustersGeoTags = []string{}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error, ExtClustersGeoTagsKey)
}

func TestResolveInvalidExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	for _, arr := range [][]string{{"good-tag", ".wrong.tag?"}, {"", ""}} {
		expected := predefinedConfig
		expected.ExtClustersGeoTags = arr
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.Error)
	}
}

func TestResolveOnlyGeoTagExistsWithinExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	tag := "us-west1"
	expected := predefinedConfig
	expected.ClusterGeoTag = tag
	expected.ExtClustersGeoTags = []string{}
	configureEnvVar(expected)
	os.Setenv(ExtClustersGeoTagsKey, tag)
	resolver := NewDependencyResolver()
	config, err := resolver.ResolveOperatorConfig()
	assert.Error(t, err)
	assert.Equal(t, expected, *config)
}

func TestResolveGeoTagExistsWithinExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	tag := "us-west1"
	for _, arr := range [][]string{{"good-tag"}, {"us-east1", "eu"}} {
		expected := predefinedConfig
		expected.ClusterGeoTag = tag
		expected.ExtClustersGeoTags = arr
		configureEnvVar(expected)
		os.Setenv(ExtClustersGeoTagsKey, strings.Join(append(arr, tag), ","))
		// act,assert
		resolver := NewDependencyResolver()
		// act
		config, err := resolver.ResolveOperatorConfig()
		// assert
		assert.NoError(t, err)
		assert.Equal(t, expected, *config)
	}
}

func TestResolveGeoTagWithRepeatingExtGeoTags(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.ExtClustersGeoTags = []string{"foo", "blah", "foo"}
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestRoute53HostedZoneIDSet(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Route53HostedZoneID = "Z13374242ABCDEFGH5ZI"
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestRoute53HostedZoneIDMalformed(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Route53HostedZoneID = "asdf"
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestBothRoute53AndInfobloxAreEnabled(t *testing.T) {
	// arrange
	defer cleanup()
	customConfig := predefinedConfig
	customConfig.Infoblox.Host = "Infoblox.domain"
	customConfig.Infoblox.Version = "0.0.1"
	customConfig.Infoblox.Port = 443
	customConfig.Infoblox.Username = defaultInfobloxUsername
	customConfig.Infoblox.Password = defaultInfobloxPassword
	configureEnvVar(customConfig)
	_ = os.Setenv(ExtDNSEnabledKey, "true")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Equal(t, DNSTypeMultipleProviders, config.EdgeDNSType)
}

func TestRoute53NS1AndInfobloxAreConfigured(t *testing.T) {
	// arrange
	defer cleanup()
	// predefinedConfig has Infoblox preconfigured
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(ExtDNSEnabledKey, "true")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	recognizedEdgeDNSType, recognizedEdgeDNSTypes := getEdgeDNSType(config)
	// assert
	assert.Error(t, err)
	assert.Equal(t, DNSTypeMultipleProviders, config.EdgeDNSType)
	assert.Equal(t, recognizedEdgeDNSType, config.EdgeDNSType)
	assert.Equal(t, recognizedEdgeDNSTypes, []EdgeDNSType{DNSTypeExternal, DNSTypeInfoblox})
}

func TestNoDNSIsConfigured(t *testing.T) {
	// arrange
	defer cleanup()
	customConfig := predefinedConfig
	customConfig.Infoblox.Host = ""
	configureEnvVar(customConfig)
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	recognizedEdgeDNSType, recognizedEdgeDNSTypes := getEdgeDNSType(config)
	// assert
	assert.NoError(t, err)
	assert.Equal(t, DNSTypeNoEdgeDNS, config.EdgeDNSType)
	assert.Equal(t, recognizedEdgeDNSType, config.EdgeDNSType)
	assert.Equal(t, recognizedEdgeDNSTypes, []EdgeDNSType{})
}

func TestRoute53IsDisabledAndInfobloxIsNotConfigured(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeNoEdgeDNS
	expected.extDNSEnabled = false
	expected.Infoblox.Host = ""
	// act,assert
	// that's how our integration tests are running
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestRoute53IsDisabledButInfobloxIsConfigured(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.extDNSEnabled = false
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = "Infoblox.domain"
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestRoute53IsEnabledButInfobloxIsNotConfigured(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.extDNSEnabled = true
	expected.EdgeDNSType = DNSTypeExternal
	expected.Infoblox.Host = ""
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestInfobloxGridHostIsEmpty(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeExternal
	expected.extDNSEnabled = true
	expected.Infoblox.Host = ""
	expected.Infoblox.Version = ""
	expected.Infoblox.Port = 0
	expected.Infoblox.Username = ""
	expected.Infoblox.Password = ""
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestInfobloxGridHostIsNotEmpty(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = defaultHost
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestInfobloxGridHostIsNotEmptyButInfobloxPropsAreEmpty(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = defaultHost
	expected.Infoblox.Version = ""
	expected.Infoblox.Port = 0
	expected.Infoblox.Username = ""
	expected.Infoblox.Password = ""
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestInfobloxGridHostIsEmptyButInfobloxPropsAreFilled(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeExternal
	expected.extDNSEnabled = true
	expected.Infoblox.Host = ""
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestInfobloxGridHostIsUnset(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeNoEdgeDNS
	expected.extDNSEnabled = false
	expected.Infoblox.Host = ""
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	// values are ignored and not validated
	arrangeVariablesAndAssert(t, expected, assert.NoError, InfobloxGridHostKey)
}

func TestInfobloxGridHostIsInvalid(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.extDNSEnabled = false
	expected.Infoblox.Host = "dnfkjdnf kj"
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = defaultInfobloxUsername
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestInfobloxVersionIsValid(t *testing.T) {
	// arrange
	defer cleanup()
	// version can be empty!
	for _, v := range []string{"0.0.1", "v0.0.1", "v0.0.0-patch1", "2.3.5-patch1"} {
		expected := predefinedConfig
		expected.EdgeDNSType = DNSTypeInfoblox
		expected.Infoblox.Host = defaultHost
		expected.Infoblox.Version = v
		expected.Infoblox.Port = 443
		expected.Infoblox.Username = defaultInfobloxUsername
		expected.Infoblox.Password = defaultInfobloxPassword
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.NoError)
	}
}

func TestInfobloxVersionIsInvalid(t *testing.T) {
	// arrange
	defer cleanup()
	for _, v := range []string{"0.1.*", "kkojo", "k12k", ""} {
		expected := predefinedConfig
		expected.EdgeDNSType = DNSTypeInfoblox
		expected.Infoblox.Host = defaultHost
		expected.Infoblox.Version = v
		expected.Infoblox.Port = 443
		expected.Infoblox.Username = defaultInfobloxUsername
		expected.Infoblox.Password = defaultInfobloxPassword
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.Error)
	}
}

func TestInvalidInfobloxPort(t *testing.T) {
	// arrange
	defer cleanup()
	for _, p := range []int{-1, 0, 65536} {
		expected := predefinedConfig
		expected.EdgeDNSType = DNSTypeInfoblox
		expected.Infoblox.Host = defaultHost
		expected.Infoblox.Version = defaultVersion
		expected.Infoblox.Port = p
		expected.Infoblox.Username = defaultInfobloxUsername
		expected.Infoblox.Password = defaultInfobloxPassword
		// act,assert
		arrangeVariablesAndAssert(t, expected, assert.Error)
	}
}

func TestValidInfobloxUserPasswordAndPort(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = defaultHost
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = "infobloxUser"
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestEmptyInfobloxUser(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = defaultHost
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = ""
	expected.Infoblox.Password = defaultInfobloxPassword
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestEmptyInfobloxPassword(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.EdgeDNSType = DNSTypeInfoblox
	expected.Infoblox.Host = defaultHost
	expected.Infoblox.Version = defaultVersion
	expected.Infoblox.Port = 443
	expected.Infoblox.Username = "infobloxUser"
	expected.Infoblox.Password = ""
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestValidInfobloxHTTPPoolConnections(t *testing.T) {
	// arrange
	defer cleanup()
	// act,assert
	arrangeVariablesAndAssert(t, predefinedConfig, assert.NoError)
}

func TestInvalidInfobloxHTTPPoolConnections(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(InfobloxHTTPPoolConnectionsKey, "i.am.wrong??.")
	resolver := NewDependencyResolver()
	// act
	_, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
}

func TestZeroInfobloxHTTPPoolConnections(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Infoblox.HTTPPoolConnections = 0
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestNegativeInfobloxHTTPPoolConnections(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Infoblox.HTTPPoolConnections = -1
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestValidInfobloxHTTPRequestTimeout(t *testing.T) {
	// arrange
	defer cleanup()
	// act,assert
	arrangeVariablesAndAssert(t, predefinedConfig, assert.NoError)
}

func TestZeroInfobloxHTTPRequestTimeout(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Infoblox.HTTPRequestTimeout = 0
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestNegativeInfobloxHTTPRequestTimeout(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Infoblox.HTTPRequestTimeout = -1
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestResolveLoggerUseDefaultValue(t *testing.T) {
	// arrange
	// Build zerolog from empty string which is equal to zerolog.NoLevel.
	// Depresolver handles it "" and use default value - info level
	defer cleanup()
	expected := predefinedConfig
	expected.Log.Level = zerolog.InfoLevel
	expected.Log.level = zerolog.InfoLevel.String()
	expected.Log.NoColor = false
	// act
	// assert
	arrangeVariablesAndAssert(t, expected, assert.NoError, LogLevelKey, LogFormatKey, LogNoColorKey)
}

func TestResolveLoggerOutputFormatMode(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.Log.Format = SimpleFormat
	expected.Log.Level = zerolog.InfoLevel
	expected.Log.level = zerolog.InfoLevel.String()
	// act
	// assert
	arrangeVariablesAndAssert(t, expected, assert.NoError, LogLevelKey)
}

func TestResolveLoggerDebugMode(t *testing.T) {
	// arrange
	expected := predefinedConfig
	expected.Log.Level = zerolog.DebugLevel
	// act
	// assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveLoggerNoColor(t *testing.T) {
	// arrange
	expected := predefinedConfig
	expected.Log.NoColor = true
	// act
	// assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveLoggerInfoMode(t *testing.T) {
	// arrange
	expected := predefinedConfig
	expected.Log.Level = zerolog.InfoLevel
	expected.Log.level = zerolog.InfoLevel.String()
	// act
	// assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestResolveLoggerCaseInsensitiveMode(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(LogLevelKey, "WARn")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.NoError(t, err)
	assert.Equal(t, zerolog.WarnLevel, config.Log.Level)
}

func TestResolveLoggerCaseInsensitiveOutputFormat(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(LogFormatKey, "Json")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.NoError(t, err)
	assert.Equal(t, JSONFormat, config.Log.Format)
}

func TestResolveLoggerLevelWithInvalidValue(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(LogLevelKey, "i.am.wrong??.")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Equal(t, zerolog.NoLevel, config.Log.Level)
	assert.Equal(t, SimpleFormat, config.Log.Format)
}

func TestResolveLoggerOutputWithInvalidValue(t *testing.T) {
	// arrange
	defer cleanup()
	configureEnvVar(predefinedConfig)
	_ = os.Setenv(LogFormatKey, "i.am.wrong??.")
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Equal(t, NoFormat, config.Log.Format)
}

func TestResolveConfigSplitBrainCheckEnabled(t *testing.T) {
	// arrange
	defer cleanup()
	expected := predefinedConfig
	expected.SplitBrainCheck = true
	// act,assert
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestHeartBeatWithMultipleExtClusterGeoTag(t *testing.T) {
	const geoTag = "test-gslb-1"
	// arrange
	defer cleanup()
	customConfig := predefinedConfig
	customConfig.DNSZone = defaultDNSZone
	customConfig.EdgeDNSZone = defaultEdgeDNSZone
	customConfig.ClusterGeoTag = defaultClusterGeoTagUs1
	customConfig.ExtClustersGeoTags = []string{defaultClusterGeoTagUs2, defaultClusterGeoTagEu}
	configureEnvVar(customConfig)
	resolver := NewDependencyResolver()

	// act
	config, err := resolver.ResolveOperatorConfig()

	// assert
	assert.NoError(t, err)
	assert.Len(t, config.GetExternalClusterHeartbeatFQDNs(geoTag), 2)
	assert.Equal(t, "test-gslb-1-heartbeat-us-west-1.cloud.example.com", config.GetClusterHeartbeatFQDN(geoTag))

	for k, v := range map[string]string{defaultClusterGeoTagUs2: "test-gslb-1-heartbeat-us-east-1.cloud.example.com",
		defaultClusterGeoTagEu: "test-gslb-1-heartbeat-eu-central-1.cloud.example.com"} {
		assert.Equal(t, config.GetExternalClusterHeartbeatFQDNs(geoTag)[k], v)
	}
}

func TestHeartBeatWithOneExtClusterGeoTag(t *testing.T) {
	const geoTag = "test-gslb-1"
	// arrange
	defer cleanup()
	customConfig := predefinedConfig
	customConfig.DNSZone = defaultDNSZone
	customConfig.EdgeDNSZone = defaultEdgeDNSZone
	customConfig.ClusterGeoTag = defaultClusterGeoTagUs1
	customConfig.ExtClustersGeoTags = []string{defaultClusterGeoTagUs2}
	configureEnvVar(customConfig)
	resolver := NewDependencyResolver()

	// act
	config, err := resolver.ResolveOperatorConfig()

	// assert
	assert.NoError(t, err)
	assert.Len(t, config.GetExternalClusterHeartbeatFQDNs(geoTag), 1)
	assert.Equal(t, "test-gslb-1-heartbeat-us-west-1.cloud.example.com", config.GetClusterHeartbeatFQDN(geoTag))
	assert.Equal(t, config.GetExternalClusterHeartbeatFQDNs(geoTag)[defaultClusterGeoTagUs2], "test-gslb-1-heartbeat-us-east-1.cloud.example.com")
}

func TestNsServerNamesWithMultipleExtClusterGeoTag(t *testing.T) {
	// arrange
	defer cleanup()
	customConfig := predefinedConfig
	customConfig.DNSZone = defaultDNSZone
	customConfig.EdgeDNSZone = defaultEdgeDNSZone
	customConfig.ClusterGeoTag = defaultClusterGeoTagUs1
	customConfig.ExtClustersGeoTags = []string{defaultClusterGeoTagUs2, defaultClusterGeoTagEu}
	configureEnvVar(customConfig)
	resolver := NewDependencyResolver()

	// act
	config, err := resolver.ResolveOperatorConfig()

	// assert
	assert.NoError(t, err)
	assert.Len(t, config.GetExternalClusterNSNames(), 2)
	assert.Equal(t, "gslb-ns-us-west-1-k8gb-test-preprod-gslb.cloud.example.com", config.GetClusterNSName())
	for k, v := range map[string]string{defaultClusterGeoTagUs2: "gslb-ns-us-east-1-k8gb-test-preprod-gslb.cloud.example.com",
		defaultClusterGeoTagEu: "gslb-ns-eu-central-1-k8gb-test-preprod-gslb.cloud.example.com"} {
		assert.Equal(t, config.GetExternalClusterNSNames()[k], v)
	}
}

func TestNsServerNamesForLocalEdgeDNS(t *testing.T) {
	// arrange
	defer cleanup()
	for _, edgeDNSServer := range []string{"127.0.0.1", "localhost"} {
		customConfig := predefinedConfig
		customConfig.EdgeDNSServers = []utils.DNSServer{
			{
				Host: edgeDNSServer,
				Port: 53,
			},
		}
		configureEnvVar(customConfig)
		resolver := NewDependencyResolver()
		// act
		config, err := resolver.ResolveOperatorConfig()
		// assert
		assert.NoError(t, err)
		assert.Equal(t, config.GetClusterNSName(), edgeDNSServer)
		assert.True(t, reflect.DeepEqual(config.GetExternalClusterNSNames(), map[string]string{"za": edgeDNSServer, "eu": edgeDNSServer}))
	}
}

func TestNsServerNamesWithOneExtClusterGeoTag(t *testing.T) {
	// arrange
	defer cleanup()
	customConfig := predefinedConfig
	customConfig.DNSZone = defaultDNSZone
	customConfig.EdgeDNSZone = defaultEdgeDNSZone
	customConfig.ClusterGeoTag = defaultClusterGeoTagUs1
	customConfig.ExtClustersGeoTags = []string{"location-2"}
	configureEnvVar(customConfig)
	resolver := NewDependencyResolver()

	// act
	config, err := resolver.ResolveOperatorConfig()

	// assert
	assert.NoError(t, err)
	assert.Len(t, config.GetExternalClusterNSNames(), 1)
	assert.Equal(t, "gslb-ns-us-west-1-k8gb-test-preprod-gslb.cloud.example.com", config.GetClusterNSName())
	assert.Equal(t, config.GetExternalClusterNSNames()["location-2"], "gslb-ns-location-2-k8gb-test-preprod-gslb.cloud.example.com")
}

func TestNsServerNamesWithExtClusterGeoTagsContainingClusterGeoTag(t *testing.T) {
	// arrange
	defer cleanup()
	customConfig := predefinedConfig
	customConfig.DNSZone = defaultDNSZone
	customConfig.EdgeDNSZone = defaultEdgeDNSZone
	customConfig.ClusterGeoTag = defaultClusterGeoTagUs1
	customConfig.ExtClustersGeoTags = []string{"location-2", defaultClusterGeoTagUs1}
	configureEnvVar(customConfig)
	resolver := NewDependencyResolver()

	// act
	config, err := resolver.ResolveOperatorConfig()

	// assert
	assert.NoError(t, err)
	assert.Len(t, config.GetExternalClusterNSNames(), 1)
	assert.Equal(t, "gslb-ns-us-west-1-k8gb-test-preprod-gslb.cloud.example.com", config.GetClusterNSName())
	assert.Equal(t, config.GetExternalClusterNSNames()["location-2"], "gslb-ns-location-2-k8gb-test-preprod-gslb.cloud.example.com")
}

func TestNsServerNamesLargeDNSZone(t *testing.T) {
	defer cleanup()
	// arrange DNSZone exceeds
	customConfig := predefinedConfig
	customConfig.DNSZone = "k8gb-test-preprod-lorem-ipsum-donor-blah-blah-blah.gslb.cloud.example.com"
	customConfig.EdgeDNSZone = defaultEdgeDNSZone
	customConfig.ClusterGeoTag = "us"
	configureEnvVar(customConfig)
	resolver := NewDependencyResolver()

	// act
	config, err := resolver.ResolveOperatorConfig()

	// assert
	assert.Error(t, err)
	assert.Equal(t, "gslb-ns-us-k8gb-test-preprod-lorem-ipsum-donor-blah-blah-blah-gslb.cloud.example.com", config.GetClusterNSName())
	extNsNames := config.GetExternalClusterNSNames()
	expectedExtNsNames := map[string]string{"za": "gslb-ns-za-k8gb-test-preprod-lorem-ipsum-donor-blah-blah-blah-gslb.cloud.example.com",
		"eu": "gslb-ns-eu-k8gb-test-preprod-lorem-ipsum-donor-blah-blah-blah-gslb.cloud.example.com"}
	assert.True(t, reflect.DeepEqual(extNsNames, expectedExtNsNames), "maps must be equal: \n %v\n %v", extNsNames, expectedExtNsNames)
}

func TestNsServerNamesWithLargeExtClusterGeoTag(t *testing.T) {
	const largeGeoTag = "za-lorem-ipsum-donor-b-blah-lorem"
	defer cleanup()
	// arrange
	customConfig := predefinedConfig
	customConfig.DNSZone = defaultDNSZone
	customConfig.EdgeDNSZone = defaultEdgeDNSZone
	customConfig.ClusterGeoTag = "us"
	customConfig.ExtClustersGeoTags = []string{}
	customConfig.ExtClustersGeoTags = append(customConfig.ExtClustersGeoTags, predefinedConfig.ExtClustersGeoTags...)
	customConfig.ExtClustersGeoTags[0] = largeGeoTag
	configureEnvVar(customConfig)
	resolver := NewDependencyResolver()

	// act
	config, err := resolver.ResolveOperatorConfig()

	// assert
	assert.Error(t, err)
	assert.Equal(t, "gslb-ns-us-k8gb-test-preprod-gslb.cloud.example.com", config.GetClusterNSName())
	extNsNames := config.GetExternalClusterNSNames()
	expectedExtNsNames := map[string]string{largeGeoTag: "gslb-ns-za-lorem-ipsum-donor-b-blah-lorem-k8gb-test-preprod-gslb.cloud.example.com",
		"eu": "gslb-ns-eu-k8gb-test-preprod-gslb.cloud.example.com"}
	assert.True(t, reflect.DeepEqual(extNsNames, expectedExtNsNames), "maps must be equal: \n %v\n %v", extNsNames, expectedExtNsNames)

}

func TestNsServerNamesWithLargeClusterGeoTag(t *testing.T) {
	defer cleanup()
	// arrange
	customConfig := predefinedConfig
	customConfig.DNSZone = defaultDNSZone
	customConfig.EdgeDNSZone = defaultEdgeDNSZone
	customConfig.ClusterGeoTag = "us-lorem-ipsum-donor-blah-blah-blah-blah"
	configureEnvVar(customConfig)
	resolver := NewDependencyResolver()

	// act
	config, err := resolver.ResolveOperatorConfig()

	// assert
	assert.Error(t, err)
	assert.Equal(t, "gslb-ns-us-lorem-ipsum-donor-blah-blah-blah-blah-k8gb-test-preprod-gslb.cloud.example.com", config.GetClusterNSName())
	extNsNames := config.GetExternalClusterNSNames()
	expectedExtNsNames := map[string]string{"za": "gslb-ns-za-k8gb-test-preprod-gslb.cloud.example.com",
		"eu": "gslb-ns-eu-k8gb-test-preprod-gslb.cloud.example.com"}
	assert.True(t, reflect.DeepEqual(extNsNames, expectedExtNsNames), "maps must be equal: \n %v\n %v", extNsNames, expectedExtNsNames)

}

func TestNsServerNamesWithExceededDNSNameSize(t *testing.T) {
	// arrange
	defer cleanup()
	customConfig := predefinedConfig
	customConfig.EdgeDNSZone = "seo.cloud.example01.lorem.ipsum.alfa.bravo.charlie.delta.echo.foxtrot.golf.hotel.india." +
		"juliett.kilo.lima.mike.november.oscar.papa.quebec.romeo.sierra.tango.uniform.victor.whiskey.x-ray.yenkee.zulu." +
		"zero.cloud.example.com"
	customConfig.DNSZone = "k8gb-test-preprod.gslb." + customConfig.EdgeDNSZone
	configureEnvVar(customConfig)
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	assert.NoError(t, err)
	assert.Len(t, config.GetClusterNSName(), 253)
	assert.Len(t, config.GetExternalClusterNSNames()[customConfig.ExtClustersGeoTags[0]], 253)
	assert.Len(t, config.GetExternalClusterNSNames()[customConfig.ExtClustersGeoTags[1]], 253)

	// arrange
	// extend cluster geo tag with one character so NsServerName exceeds length limit
	customConfig.ClusterGeoTag += "1"
	configureEnvVar(customConfig)
	resolver = NewDependencyResolver()
	// act
	config, err = resolver.ResolveOperatorConfig()
	// assert
	assert.Error(t, err)
	assert.Len(t, config.GetClusterNSName(), 254)
	assert.Len(t, config.GetExternalClusterNSNames()[customConfig.ExtClustersGeoTags[0]], 253)
	assert.Len(t, config.GetExternalClusterNSNames()[customConfig.ExtClustersGeoTags[1]], 253)
}

func TestMetricsAddressIsValid(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.0:9091"
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestMetricsAddressPortLimitExceed(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.0:80091"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressPortLimitUnder(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.0:1024"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressInvalidPort(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.0:808x"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressInvalidHost(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "x.y.z??:8080"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressWrongFormatMultipleParts(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.0:8080:9090"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressWrongFormatSinglePart(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "0.0.0.08080"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressInvalidEnvVariable(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "invalid"
	arrangeVariablesAndAssert(t, expected, assert.Error)
}

func TestMetricsAddressEmptyHost(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = ":8080"
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

func TestMetricsAddressWithValidHostName(t *testing.T) {
	defer cleanup()
	expected := predefinedConfig
	expected.MetricsAddress = "address.com:8080"
	arrangeVariablesAndAssert(t, expected, assert.NoError)
}

// arrangeVariablesAndAssert sets string environment variables and asserts `expected` argument with
// ResolveOperatorConfig() output. The last parameter unsets the values
func arrangeVariablesAndAssert(t *testing.T, expected Config,
	errf func(t assert.TestingT, err error, msgAndArgs ...interface{}) bool, unset ...string) {
	configureEnvVar(expected)
	for _, v := range unset {
		_ = os.Unsetenv(v)
	}
	resolver := NewDependencyResolver()
	// act
	config, err := resolver.ResolveOperatorConfig()
	// assert
	if config == nil {
		t.Fatal("nil *config returned")
	}
	assert.Equal(t, expected, *config)
	errf(t, err)
}

func cleanup() {
	for _, s := range []string{ReconcileRequeueSecondsKey, ClusterGeoTagKey, ExtClustersGeoTagsKey, EdgeDNSZoneKey, DNSZoneKey, EdgeDNSServersKey,
		ExtDNSEnabledKey, InfobloxGridHostKey, InfobloxVersionKey, InfobloxPortKey, InfobloxUsernameKey,
		InfobloxPasswordKey, K8gbNamespaceKey, CoreDNSExposedKey, InfobloxHTTPRequestTimeoutKey,
		InfobloxHTTPPoolConnectionsKey, LogLevelKey, LogFormatKey, LogNoColorKey, MetricsAddressKey, Route53HostedZoneIDKey, SplitBrainCheckKey} {
		if os.Unsetenv(s) != nil {
			panic(fmt.Errorf("cleanup %s", s))
		}
	}
}

func configureEnvVar(config Config) {
	_ = os.Unsetenv(EdgeDNSServerKey)
	_ = os.Unsetenv(EdgeDNSServerPortKey)
	_ = os.Setenv(ReconcileRequeueSecondsKey, strconv.Itoa(config.ReconcileRequeueSeconds))
	_ = os.Setenv(ClusterGeoTagKey, config.ClusterGeoTag)
	_ = os.Setenv(ExtClustersGeoTagsKey, strings.Join(config.ExtClustersGeoTags, ","))
	_ = os.Setenv(EdgeDNSServersKey, config.EdgeDNSServers.String())
	_ = os.Setenv(EdgeDNSZoneKey, config.EdgeDNSZone)
	_ = os.Setenv(DNSZoneKey, config.DNSZone)
	_ = os.Setenv(K8gbNamespaceKey, config.K8gbNamespace)
	_ = os.Setenv(ExtDNSEnabledKey, strconv.FormatBool(config.extDNSEnabled))
	_ = os.Setenv(CoreDNSExposedKey, strconv.FormatBool(config.CoreDNSExposed))
	_ = os.Setenv(InfobloxGridHostKey, config.Infoblox.Host)
	_ = os.Setenv(InfobloxVersionKey, config.Infoblox.Version)
	_ = os.Setenv(InfobloxPortKey, strconv.Itoa(config.Infoblox.Port))
	_ = os.Setenv(InfobloxUsernameKey, config.Infoblox.Username)
	_ = os.Setenv(InfobloxPasswordKey, config.Infoblox.Password)
	_ = os.Setenv(InfobloxHTTPRequestTimeoutKey, strconv.Itoa(config.Infoblox.HTTPRequestTimeout))
	_ = os.Setenv(InfobloxHTTPPoolConnectionsKey, strconv.Itoa(config.Infoblox.HTTPPoolConnections))
	_ = os.Setenv(LogLevelKey, config.Log.Level.String())
	_ = os.Setenv(LogFormatKey, config.Log.Format.String())
	_ = os.Setenv(LogNoColorKey, strconv.FormatBool(config.Log.NoColor))
	_ = os.Setenv(MetricsAddressKey, config.MetricsAddress)
	_ = os.Setenv(Route53HostedZoneIDKey, config.Route53HostedZoneID)
	_ = os.Setenv(SplitBrainCheckKey, strconv.FormatBool(config.SplitBrainCheck))
}

func getTestContext(testData string) (client.Client, *k8gbv1beta1.Gslb) {
	// Create a fake client to mock API calls.
	var gslbYaml, err = ioutil.ReadFile(testData)
	if err != nil {
		panic(fmt.Errorf("can't open example CR file: %s", testData))
	}
	gslb, err := utils.YamlToGslb(gslbYaml)
	if err != nil {
		panic(err)
	}
	objs := []runtime.Object{
		gslb,
	}
	// Register operator types with the runtime scheme.
	s := scheme.Scheme
	s.AddKnownTypes(k8gbv1beta1.GroupVersion, gslb)
	// Register external-dns DNSEndpoint CRD
	s.AddKnownTypes(schema.GroupVersion{Group: "externaldns.k8s.io", Version: "v1alpha1"}, &externaldns.DNSEndpoint{})
	cl := fake.NewClientBuilder().WithScheme(s).WithRuntimeObjects(objs...).Build()
	return cl, gslb
}
