package depresolver

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/k8gb-io/k8gb/controllers/internal/utils"
)

const (
	// hostNameRegex allows cloud region formats; e.g. af-south-1
	geoTagRegex = "^[a-zA-Z\\-\\d]*$"
	// hostNameRegex is valid as per RFC 1123 that allows hostname segments could start with a digit
	hostNamePart  = "(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])"
	hostNameRegex = "^" + hostNamePart + "$"
	// hostnames are valid as per the previous regexp, it may also contain :123 port and multiple comma-separated entries are supported
	hostNamesWithPortsRegex1 = "^(" + hostNamePart + "(:\\d{1,5})?(\\s*,\\s*)?)+$"
	// doesn't end with comma or space (golang doesn't support negative lookbehind regexps)
	hostNamesWithPortsRegex2 = "^.*[^,]$"
	// ipAddressRegex matches valid IPv4 addresses
	ipAddressRegex = "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$"
	// versionNumberRegex matches version in formats 0.1.2, v0.1.2, v0.1.2-alpha
	versionNumberRegex = "^(v){0,1}(0|(?:[1-9]\\d*))(?:\\.(0|(?:[1-9]\\d*))(?:\\.(0|(?:[1-9]\\d*)))?(?:\\-([\\w][\\w\\.\\-_]*))?)?$"
	// k8sNamespaceRegex matches valid kubernetes namespace
	k8sNamespaceRegex = "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
)

// validator wrapper against field to be verified
type validator struct {
	strValue string
	strArr   []string
	intValue int
	name     string
	err      error
}

// field creates validator
func field(name string, value interface{}) *validator {
	validator := new(validator)
	validator.name = name
	switch v := value.(type) {
	case int:
		validator.intValue = v
	case int8:
		validator.intValue = int(v)
	case int16:
		validator.intValue = int(v)
	case int32:
		validator.intValue = int(v)
	case int64:
		validator.intValue = int(v)
	case string:
		validator.strValue = v
	case []string:
		validator.strArr = v
	case utils.DNSList:
		validator.strValue = v.String()
	default:
		// float32, float64, bool, interface{}, maps, slices, Custom Types
		validator.err = fmt.Errorf("can't parse '%v' of type '%T' as int or string", v, v)
	}
	return validator
}

func (v *validator) isNotEmpty() *validator {
	if v.err != nil {
		return v
	}
	if v.strValue == "" {
		v.err = fmt.Errorf("'%s' is empty", v.name)
	}
	return v
}

func (v *validator) matchRegexp(regex string) *validator {
	if v.err != nil {
		return v
	}
	if v.strValue == "" {
		return v
	}
	r, _ := regexp.Compile(regex)
	if !r.Match([]byte(v.strValue)) {
		v.err = fmt.Errorf(`'%s' does not match given criteria. see: https://www.regextester.com (%s)`, v.strValue, regex)
	}
	return v
}

// matchRegexps returns error if value is not matched by any of regexp
func (v *validator) matchRegexps(regex ...string) *validator {
	if v.err != nil {
		return v
	}
	for _, r := range regex {
		v.err = nil
		if v.matchRegexp(r).err == nil {
			return v
		}
	}
	return v
}

func (v *validator) isHigherThanZero() *validator {
	if v.err != nil {
		return v
	}
	if v.intValue <= 0 {
		v.err = fmt.Errorf(`'%s' is less or equal to zero`, v.name)
	}
	return v
}

func (v *validator) isHigherOrEqualToZero() *validator {
	if v.err != nil {
		return v
	}
	if v.intValue < 0 {
		v.err = fmt.Errorf(`'%s' is less than zero`, v.name)
	}
	return v
}

func (v *validator) isLessOrEqualTo(num int) *validator {
	if v.err != nil {
		return v
	}
	if v.intValue > num {
		v.err = fmt.Errorf(`'%s' is higher than '%v'`, v.name, num)
	}
	return v
}

func (v *validator) isHigherThan(num int) *validator {
	if v.err != nil {
		return v
	}
	if v.intValue <= num {
		v.err = fmt.Errorf(`'%s' is higher than '%v'`, v.name, num)
	}
	return v
}

func (v *validator) hasItems() *validator {
	if v.err != nil {
		return v
	}
	if len(v.strArr) == 0 {
		v.err = fmt.Errorf(`'%s' should contain at least one item`, v.name)
	}
	return v
}

func (v *validator) hasUniqueItems() *validator {
	if v.err != nil {
		return v
	}
	m := make(map[string]bool)
	for _, s := range v.strArr {
		m[s] = true
	}
	if len(m) != len(v.strArr) {
		v.err = fmt.Errorf(`'%s' contains redundant values '%s'`, v.name, v.strArr)
	}
	return v
}

func (v *validator) isOneOf(items ...string) *validator {
	if v.err != nil {
		return v
	}
	for _, item := range items {
		if item == v.strValue {
			return v
		}
	}
	v.err = fmt.Errorf(`'%s' must be one of the values %v`, v.name, items)
	return v
}

func isNotEmpty(s string) bool {
	return strings.ReplaceAll(s, " ", "") != ""
}
