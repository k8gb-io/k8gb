/*
Copyright 2021 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/
package assistant

import (
	"context"
	coreerrors "errors"
	"fmt"
	"strings"
	"time"

	k8gbv1beta1 "github.com/AbsaOSS/k8gb/api/v1beta1"
	"github.com/AbsaOSS/k8gb/controllers/internal/utils"
	"github.com/AbsaOSS/k8gb/controllers/logging"

	str "github.com/AbsaOSS/gopkg/strings"
	"github.com/miekg/dns"
	corev1 "k8s.io/api/core/v1"
	v1beta1 "k8s.io/api/networking/v1beta1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
	externaldns "sigs.k8s.io/external-dns/endpoint"
)

const coreDNSServiceLabel = "app.kubernetes.io/name=coredns"

// Gslb is common wrapper operating on GSLB instance.
// It uses apimachinery client to call kubernetes API
type Gslb struct {
	client            client.Client
	k8gbNamespace     string
	edgeDNSServer     string
	edgeDNSServerPort int
}

var log = logging.Logger()

func NewGslbAssistant(client client.Client, k8gbNamespace, edgeDNSServer string, edgeDNSServerPort int) *Gslb {
	return &Gslb{
		client:            client,
		k8gbNamespace:     k8gbNamespace,
		edgeDNSServer:     edgeDNSServer,
		edgeDNSServerPort: edgeDNSServerPort,
	}
}

// CoreDNSExposedIPs retrieves list of IP's exposed by CoreDNS
func (r *Gslb) CoreDNSExposedIPs() ([]string, error) {
	serviceList := &corev1.ServiceList{}
	coreDNSService := &corev1.Service{}
	sel, err := labels.Parse(coreDNSServiceLabel)
	if err != nil {
		log.Error().Err(err).Msg("Badly formed label selector")
		return nil, err
	}
	listOption := &client.ListOptions{
		LabelSelector: sel,
		Namespace:     r.k8gbNamespace,
	}

	err = r.client.List(context.TODO(), serviceList, listOption)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Warn().Err(err).Msg("Can't find CoreDNS service")
		}
	}
	if len(serviceList.Items) != 1 {
		log.Warn().Msg("More than 1 CoreDNS service was found")
		for _, service := range serviceList.Items {
			log.Info().
				Str("ServiceName", service.Name).
				Msg("Found CoreDNS service")
		}
		err := coreerrors.New("more than 1 CoreDNS service was found. Check if CoreDNS exposed correctly")
		return nil, err
	}
	coreDNSService = &serviceList.Items[0]

	var lbHostname string
	if len(coreDNSService.Status.LoadBalancer.Ingress) > 0 {
		lbHostname = coreDNSService.Status.LoadBalancer.Ingress[0].Hostname
	} else {
		errMessage := "no LoadBalancer ExternalIPs are found"
		log.Warn().
			Str("ServiceName", coreDNSService.Name).
			Msg(errMessage)
		err := coreerrors.New(errMessage)
		return nil, err
	}
	IPs, err := utils.Dig(r.edgeDNSServer, lbHostname)
	if err != nil {
		log.Warn().Err(err).
			Str("LoadBalancerHostname", lbHostname).
			Msg("Can't dig CoreDNS service LoadBalancer FQDN")
		return nil, err
	}
	return IPs, nil
}

// GslbIngressExposedIPs retrieves list of IP's exposed by all GSLB ingresses
func (r *Gslb) GslbIngressExposedIPs(gslb *k8gbv1beta1.Gslb) ([]string, error) {
	nn := types.NamespacedName{
		Name:      gslb.Name,
		Namespace: gslb.Namespace,
	}

	gslbIngress := &v1beta1.Ingress{}

	err := r.client.Get(context.TODO(), nn, gslbIngress)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Info().
				Str("gslb", gslb.Name).
				Msg("Can't find gslb Ingress")
		}
		return nil, err
	}

	var gslbIngressIPs []string

	for _, ip := range gslbIngress.Status.LoadBalancer.Ingress {
		if len(ip.IP) > 0 {
			gslbIngressIPs = append(gslbIngressIPs, ip.IP)
		}
		if len(ip.Hostname) > 0 {
			IPs, err := utils.Dig(r.edgeDNSServer, ip.Hostname)
			if err != nil {
				log.Warn().Err(err).Msg("Dig error")
				return nil, err
			}
			gslbIngressIPs = append(gslbIngressIPs, IPs...)
		}
	}

	return gslbIngressIPs, nil
}

// SaveDNSEndpoint update DNS endpoint or create new one if doesnt exist
func (r *Gslb) SaveDNSEndpoint(namespace string, i *externaldns.DNSEndpoint) error {
	found := &externaldns.DNSEndpoint{}
	err := r.client.Get(context.TODO(), types.NamespacedName{
		Name:      i.Name,
		Namespace: namespace,
	}, found)
	if err != nil && errors.IsNotFound(err) {

		// Create the DNSEndpoint
		log.Info().Msgf("Creating a new DNSEndpoint:\n %s", str.ToString(i))
		err = r.client.Create(context.TODO(), i)

		if err != nil {
			// Creation failed
			log.Err(err).
				Str("namespace", i.Namespace).
				Str("name", i.Name).
				Msg("Failed to create new DNSEndpoint")
			return err
		}
		// Creation was successful
		return nil
	} else if err != nil {
		// Error that isn't due to the service not existing
		log.Err(err).Msg("Failed to get DNSEndpoint")
		return err
	}

	// Update existing object with new spec, labels and annotations
	found.Spec = i.Spec
	found.ObjectMeta.Annotations = i.ObjectMeta.Annotations
	found.ObjectMeta.Labels = i.ObjectMeta.Labels
	err = r.client.Update(context.TODO(), found)

	if err != nil {
		// Update failed
		log.Err(err).
			Str("namespace", found.Namespace).
			Str("name", found.Name).
			Msg("Failed to update DNSEndpoint")
		return err
	}
	return nil
}

// RemoveEndpoint removes endpoint
func (r *Gslb) RemoveEndpoint(endpointName string) error {
	log.Info().
		Str("namespace", r.k8gbNamespace).
		Str("name", endpointName).
		Msg("Removing endpoint")
	dnsEndpoint := &externaldns.DNSEndpoint{}
	err := r.client.Get(context.Background(), client.ObjectKey{Namespace: r.k8gbNamespace, Name: endpointName}, dnsEndpoint)
	if err != nil {
		if errors.IsNotFound(err) {
			log.Warn().
				Str("namespace", r.k8gbNamespace).
				Str("name", endpointName).
				Err(err).
				Msg("Endpoint not found")
			return nil
		}
		return err
	}
	err = r.client.Delete(context.TODO(), dnsEndpoint)
	return err
}

// InspectTXTThreshold inspects fqdn TXT record from edgeDNSServer. If record doesn't exists or timestamp is greater than
// splitBrainThreshold the error is returned.
func (r *Gslb) InspectTXTThreshold(fqdn string, splitBrainThreshold time.Duration) error {
	m := new(dns.Msg)
	m.SetQuestion(dns.Fqdn(fqdn), dns.TypeTXT)
	ns := fmt.Sprintf("%s:%v", r.edgeDNSServer, r.edgeDNSServerPort)
	txt, err := dns.Exchange(m, ns)
	if err != nil {
		log.Info().
			Str("edgeDNS", ns).
			Err(err).
			Msg("Contacting EdgeDNS server for TXT split brain record")
		return err
	}
	if len(txt.Answer) > 0 {
		if t, ok := txt.Answer[0].(*dns.TXT); ok {
			timestamp := strings.Split(t.String(), "\t")[4]
			timestamp = strings.Trim(timestamp, "\"") // Otherwise time.Parse() will miserably fail
			timeFromTXT, err := time.Parse("2006-01-02T15:04:05", timestamp)
			if err != nil {
				log.Err(err).
					Str("raw record", t.String()).
					Str("raw timestamp", timestamp).
					Msg("Split brain TXT: can't parse timestamp")
				return err
			}
			now := time.Now().UTC()
			diff := now.Sub(timeFromTXT)
			log.Debug().
				Str("raw record", t.String()).
				Str("raw timestamp", timestamp).
				Str("parsed", timeFromTXT.String()).
				Str("diff", diff.String()).
				Msg("Split brain TXT")

			if diff > splitBrainThreshold {
				return errors.NewResourceExpired(fmt.Sprintf("Split brain TXT record expired the time threshold: (%s)", splitBrainThreshold))
			}
			return nil
		}
	}
	return errors.NewResourceExpired(fmt.Sprintf("Can't find split brain TXT record at EdgeDNS server(%s) and record %s ", ns, fqdn))
}

func getARecords(msg *dns.Msg) []string {
	var ARecords []string
	for _, nsA := range msg.Answer {
		ip := nsA.(*dns.A).A.String()
		ARecords = append(ARecords, ip)
	}
	return ARecords
}

func dnsQuery(host string, nameserver string, nameserverport int) (*dns.Msg, error) {
	dnsMsg := new(dns.Msg)
	edgeDNSServer := fmt.Sprintf("%s:%v", nameserver, nameserverport)
	fqdn := fmt.Sprintf("%s.", host) // Convert to true FQDN with dot at the end
	dnsMsg.SetQuestion(fqdn, dns.TypeA)
	dnsMsgA, err := dns.Exchange(dnsMsg, edgeDNSServer)
	if err != nil {
		log.Warn().
			Str("fqdn", fqdn).
			Str("nameserver", nameserver).
			Err(err).
			Msg("Can't resolve FQDN using nameserver")
	}
	return dnsMsgA, err
}

func (r *Gslb) GetExternalTargets(host string, extClusterNsNames map[string]string) (targets []string) {
	targets = []string{}
	for _, cluster := range extClusterNsNames {
		// Use edgeDNSServer for resolution of NS names and fallback to local nameservers
		log.Info().
			Str("cluster", cluster).
			Msg("Adding external Gslb targets from cluster")
		glueA, err := dnsQuery(cluster, r.edgeDNSServer, r.edgeDNSServerPort)
		if err != nil {
			return
		}
		log.Info().
			Str("nameserver", cluster).
			Str("edgeDNS", fmt.Sprintf("%s:%v", r.edgeDNSServer, r.edgeDNSServerPort)).
			Str("glue A record", fmt.Sprintf("%v", glueA.Answer)).
			Msg("Resolved glue A record for NS")
		glueARecords := getARecords(glueA)
		var nameServerToUse string
		if len(glueARecords) > 0 {
			nameServerToUse = glueARecords[0]
		} else {
			nameServerToUse = cluster
		}
		host = fmt.Sprintf("localtargets-%s", host)
		a, err := dnsQuery(host, nameServerToUse, r.edgeDNSServerPort)
		if err != nil {
			return
		}
		clusterTargets := getARecords(a)
		if len(clusterTargets) > 0 {
			targets = append(targets, clusterTargets...)
			log.Info().
				Str("cluster targets", fmt.Sprintf("%s", clusterTargets)).
				Str("cluster", cluster).
				Msg("Extend Gslb targets by targets from cluster")
		}
	}
	return targets
}
