package controllers

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"fmt"
	"io/ioutil"
	"net"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/golang/mock/gomock"

	str "github.com/AbsaOSS/gopkg/string"
	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	"github.com/k8gb-io/k8gb/controllers/depresolver"
	"github.com/k8gb-io/k8gb/controllers/internal/utils"
	"github.com/k8gb-io/k8gb/controllers/logging"
	"github.com/k8gb-io/k8gb/controllers/providers/assistant"
	"github.com/k8gb-io/k8gb/controllers/providers/dns"
	"github.com/k8gb-io/k8gb/controllers/providers/metrics"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	corev1 "k8s.io/api/core/v1"
	netv1 "k8s.io/api/networking/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes/scheme"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
	externaldns "sigs.k8s.io/external-dns/endpoint"
)

type testSettings struct {
	gslb       *k8gbv1beta1.Gslb
	reconciler *GslbReconciler
	request    reconcile.Request
	config     depresolver.Config
	client     client.Client
	ingress    *netv1.Ingress
	finalCall  bool
	assistant  assistant.Assistant
}

var crSampleYaml = "../deploy/crds/k8gb.absa.oss_v1beta1_gslb_cr.yaml"

var predefinedConfig = depresolver.Config{
	ReconcileRequeueSeconds: 30,
	ClusterGeoTag:           "us-west-1",
	ExtClustersGeoTags:      []string{"us-east-1"},
	EdgeDNSServers: []utils.DNSServer{
		{
			Host: "127.0.0.1",
			Port: 7753,
		},
	},
	EdgeDNSZone:   "example.com",
	DNSZone:       "cloud.example.com",
	K8gbNamespace: "k8gb",
	Infoblox: depresolver.Infoblox{
		Host:                "fakeinfoblox.example.com",
		Username:            "foo",
		Password:            "blah",
		Port:                443,
		Version:             "0.0.0",
		HTTPPoolConnections: 20,
		HTTPRequestTimeout:  10,
	},
	Log: depresolver.Log{
		Format: depresolver.SimpleFormat,
	},
}

var fakeDNSSettings = utils.FakeDNSSettings{
	FakeDNSPort:     7753,
	EdgeDNSZoneFQDN: "example.com.",
	DNSZoneFQDN:     "cloud.example.com.",
}

const (
	defaultCoreDNSExtServiceName = "k8gb-coredns-randomname"
	defaultUnhealthyServiceName  = "unhealthy-app"
	defaultPodinfoServiceName    = "frontend-podinfo"
	defaultEdgeDNS0              = "1.0.0.1"
	defaultEdgeDNS1              = "1.1.1.1"
)

var defaultEdgeDNSServers = []utils.DNSServer{
	{
		Host: defaultEdgeDNS1,
		Port: 53,
	},
}

func TestNotFoundServiceStatus(t *testing.T) {
	// arrange
	settings := provideSettings(t, predefinedConfig)
	expectedServiceStatus := k8gbv1beta1.NotFound
	notFoundHost := "notfound.cloud.example.com"
	// act
	actualServiceStatus := settings.gslb.Status.ServiceHealth[notFoundHost]
	// assert
	assert.Equal(t, expectedServiceStatus, actualServiceStatus, "expected %s service status to be %s, but got %s",
		notFoundHost, expectedServiceStatus, actualServiceStatus)
}

func TestUnhealthyServiceStatus(t *testing.T) {
	// arrange
	settings := provideSettings(t, predefinedConfig)
	serviceName := defaultUnhealthyServiceName
	unhealthyHost := "unhealthy.cloud.example.com"
	expectedServiceStatus := k8gbv1beta1.Unhealthy
	defer deleteUnhealthyService(t, &settings, serviceName)
	// act
	createUnhealthyService(t, &settings, serviceName)
	reconcileAndUpdateGslb(t, settings)
	// assert
	actualServiceStatus := settings.gslb.Status.ServiceHealth[unhealthyHost]
	assert.Equal(t, expectedServiceStatus, actualServiceStatus, "expected %s service status to be %s, but got %s",
		unhealthyHost, expectedServiceStatus, actualServiceStatus)
}

func TestHealthyServiceStatus(t *testing.T) {
	// arrange
	settings := provideSettings(t, predefinedConfig)
	serviceName := defaultPodinfoServiceName
	expectedServiceStatus := k8gbv1beta1.Healthy
	healthyHost := "roundrobin.cloud.example.com"
	defer deleteHealthyService(t, &settings, serviceName)
	createHealthyService(t, &settings, serviceName)
	reconcileAndUpdateGslb(t, settings)
	// act
	actualServiceStatus := settings.gslb.Status.ServiceHealth[healthyHost]
	// assert
	assert.Equal(t, expectedServiceStatus, actualServiceStatus, "expected %s service status to be %s, but got %s",
		healthyHost, expectedServiceStatus, actualServiceStatus)
}

func TestHostsInStatusAreAdded(t *testing.T) {
	// arrange
	settings := provideSettings(t, predefinedConfig)
	settings.gslb.Status.Hosts = ""
	hostsInStatusBeforeReconciliation := settings.gslb.Status.Hosts
	expectedHostsInStatus := settings.reconciler.hostsToCSV(settings.gslb)

	reconcileAndUpdateGslb(t, settings)
	// act
	actualHostsInStatus := settings.gslb.Status.Hosts

	// assert
	assert.Empty(t, hostsInStatusBeforeReconciliation, "for gslb: '%s', the '.status.hosts' should be empty before reconciliation, but was: '%s'",
		settings.gslb.Name, hostsInStatusBeforeReconciliation)
	assert.NotEmpty(t, actualHostsInStatus, "for gslb: '%s', expected status.hosts to be not empty", settings.gslb.Name)
	assert.Equal(t, expectedHostsInStatus, actualHostsInStatus)
}

func TestHostsInStatusAllPresent(t *testing.T) {
	// arrange
	settings := provideSettings(t, predefinedConfig)
	var expectedHosts []string
	for _, h := range settings.gslb.Spec.Ingress.Rules {
		expectedHosts = append(expectedHosts, h.Host)
	}

	reconcileAndUpdateGslb(t, settings)
	// act
	actualHostsInStatus := settings.reconciler.hostsToCSV(settings.gslb)

	// assert
	for _, expectedHost := range expectedHosts {
		assert.Contains(t, actualHostsInStatus, expectedHost, "for gslb: %s, expecting %s to be present in status.hosts (%s)",
			settings.gslb.Name, expectedHost, actualHostsInStatus)
	}
}

func TestIngressHostsPerStatusMetric(t *testing.T) {
	// arrange
	settings := provideSettings(t, predefinedConfig)
	expectedHostsMetricCount := 3
	// act
	ingressHostsPerStatusMetric := metrics.Metrics().Get(metrics.K8gbGslbServiceStatusNum).AsGaugeVec()
	err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.gslb)
	actualHostsMetricCount := testutil.CollectAndCount(ingressHostsPerStatusMetric)
	// assert
	assert.NoError(t, err, "Failed to get expected gslb")
	assert.Equal(t, expectedHostsMetricCount, actualHostsMetricCount, "expected %v managed hosts, but got %v",
		expectedHostsMetricCount, actualHostsMetricCount)
}

func TestIngressHostsPerStatusMetricReflectionForHealthyStatus(t *testing.T) {
	// I'm running test multiple times to check that it work properly when healthy service is up and down multiple times
	for i := 0; i < 4; i++ {
		func() {
			// arrange
			settings := provideSettings(t, predefinedConfig)
			serviceName := defaultPodinfoServiceName
			defer deleteHealthyService(t, &settings, serviceName)
			expectedHostsMetric := 1.
			createHealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			// act
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.gslb)
			ingressHostsPerStatusMetric := metrics.Metrics().Get(metrics.K8gbGslbServiceStatusNum).AsGaugeVec()
			healthyHosts := ingressHostsPerStatusMetric.With(prometheus.Labels{"namespace": settings.gslb.Namespace,
				"name": settings.gslb.Name, "status": k8gbv1beta1.Healthy.String()})
			actualHostsMetric := testutil.ToFloat64(healthyHosts)
			// assert
			assert.NoError(t, err, "Failed to get expected gslb")
			assert.Equal(t, expectedHostsMetric, actualHostsMetric, "expected %v managed hosts with Healthy status, but got %v",
				expectedHostsMetric, actualHostsMetric)
		}()
	}
}

func TestIngressHostsPerStatusMetricReflectionForUnhealthyStatus(t *testing.T) {
	// arrange
	settings := provideSettings(t, predefinedConfig)
	err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.gslb)
	expectedHostsMetricCount := 0.
	// act
	ingressHostsPerStatusMetric := metrics.Metrics().Get(metrics.K8gbGslbServiceStatusNum).AsGaugeVec()
	unhealthyHosts := ingressHostsPerStatusMetric.With(prometheus.Labels{"namespace": settings.gslb.Namespace,
		"name": settings.gslb.Name, "status": k8gbv1beta1.Unhealthy.String()})
	actualHostsMetricCount := testutil.ToFloat64(unhealthyHosts)
	// assert
	assert.NoError(t, err, "Failed to get expected gslb")
	assert.Equal(t, expectedHostsMetricCount, actualHostsMetricCount, "expected %v managed hosts, but got %v",
		expectedHostsMetricCount, actualHostsMetricCount)

	// arrange
	serviceName := defaultUnhealthyServiceName
	createUnhealthyService(t, &settings, serviceName)
	defer deleteUnhealthyService(t, &settings, serviceName)
	reconcileAndUpdateGslb(t, settings)
	expectedHostsMetricCount = 1
	// act
	unhealthyHosts =
		ingressHostsPerStatusMetric.With(prometheus.Labels{"namespace": settings.gslb.Namespace,
			"name": settings.gslb.Name, "status": k8gbv1beta1.Unhealthy.String()})
	actualHostsMetricCount = testutil.ToFloat64(unhealthyHosts)
	// assert
	assert.Equal(t, expectedHostsMetricCount, actualHostsMetricCount, "expected %v managed hosts with Healthy status, but got %v",
		expectedHostsMetricCount, actualHostsMetricCount)
}

func TestIngressHostsPerStatusMetricReflectionForNotFoundStatus(t *testing.T) {
	// arrange
	settings := provideSettings(t, predefinedConfig)
	expectedHostsMetricCount := 2.0

	serviceName := defaultUnhealthyServiceName
	createUnhealthyService(t, &settings, serviceName)
	reconcileAndUpdateGslb(t, settings)
	deleteUnhealthyService(t, &settings, serviceName)

	// act
	err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.gslb)
	require.NoError(t, err, "Failed to get expected gslb")
	ingressHostsPerStatusMetric := metrics.Metrics().Get(metrics.K8gbGslbServiceStatusNum).AsGaugeVec()
	unknownHosts, err := ingressHostsPerStatusMetric.GetMetricWith(
		prometheus.Labels{"namespace": settings.gslb.Namespace, "name": settings.gslb.Name, "status": k8gbv1beta1.NotFound.String()})
	require.NoError(t, err, "Failed to get ingress metrics")
	actualHostsMetricCount := testutil.ToFloat64(unknownHosts)
	// assert
	assert.Equal(t, expectedHostsMetricCount, actualHostsMetricCount, "expected %v managed hosts with NotFound status, but got %v",
		expectedHostsMetricCount, actualHostsMetricCount)
}

func TestHealthyRecordMetric(t *testing.T) {
	// arrange
	expectedHealthyRecordsMetricCount := 3.0
	ingressIPs := []corev1.LoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
		{IP: "10.0.0.3"},
	}
	serviceName := defaultPodinfoServiceName
	settings := provideSettings(t, predefinedConfig)
	err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.gslb)
	require.NoError(t, err, "Failed to get expected gslb")
	defer deleteHealthyService(t, &settings, serviceName)
	createHealthyService(t, &settings, serviceName)
	err = settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
	require.NoError(t, err, "Failed to get expected ingress")
	settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
	err = settings.client.Status().Update(context.TODO(), settings.ingress)
	require.NoError(t, err, "Failed to update gslb Ingress Address")
	reconcileAndUpdateGslb(t, settings)
	// act
	healthyRecordsMetric := metrics.Metrics().Get(metrics.K8gbGslbHealthyRecords).AsGaugeVec()
	actualHealthyRecordsMetricCount := testutil.ToFloat64(healthyRecordsMetric)
	reconcileAndUpdateGslb(t, settings)
	// assert
	assert.Equal(t, expectedHealthyRecordsMetricCount, actualHealthyRecordsMetricCount, "expected %v healthy records, but got %v",
		expectedHealthyRecordsMetricCount, actualHealthyRecordsMetricCount)
}

func TestGslbReconciliationTotalIncrement(t *testing.T) {
	// arrange
	settings := provideSettings(t, predefinedConfig)
	cnt := testutil.ToFloat64(metrics.Metrics().Get(metrics.K8gbGslbReconciliationLoopsTotal).AsCounterVec())
	// act
	_, err := settings.reconciler.Reconcile(context.TODO(), settings.request)
	cnt2 := testutil.ToFloat64(metrics.Metrics().Get(metrics.K8gbGslbReconciliationLoopsTotal).AsCounterVec())
	// assert
	assert.NoError(t, err)
	assert.Equal(t, cnt+1, cnt2)
}

func TestGslbErrorsIncrement(t *testing.T) {
	// arrange
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	settings := provideSettings(t, predefinedConfig)
	var label = prometheus.Labels{"namespace": settings.gslb.Namespace, "name": settings.gslb.Name}
	m := dns.NewMockProvider(ctrl)
	cnt := testutil.ToFloat64(metrics.Metrics().Get(metrics.K8gbGslbErrorsTotal).AsCounterVec().With(label))
	m.EXPECT().GslbIngressExposedIPs(gomock.Any()).Return([]string{}, nil).Times(1)
	m.EXPECT().SaveDNSEndpoint(gomock.Any(), gomock.Any()).Return(fmt.Errorf("save DNS error")).Times(1)
	m.EXPECT().GetExternalTargets(gomock.Any()).Return(assistant.Targets{}).AnyTimes()
	m.EXPECT().CreateZoneDelegationForExternalDNS(gomock.Any()).Return(nil).AnyTimes()
	settings.reconciler.DNSProvider = m
	// act
	_, err := settings.reconciler.Reconcile(context.TODO(), settings.request)
	require.Error(t, err)
	// let's break it on different place
	m.EXPECT().SaveDNSEndpoint(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()
	m.EXPECT().GslbIngressExposedIPs(gomock.Any()).Return([]string{}, fmt.Errorf("exposed IP's error")).AnyTimes()
	_, err = settings.reconciler.Reconcile(context.TODO(), settings.request)
	cnt2 := testutil.ToFloat64(metrics.Metrics().Get(metrics.K8gbGslbErrorsTotal).AsCounterVec().With(label))
	// assert
	assert.Error(t, err)
	assert.Equal(t, cnt+2, cnt2)
}

func TestGslbCreatesDNSEndpointCRForHealthyIngressHosts(t *testing.T) {
	// arrange
	serviceName := defaultPodinfoServiceName
	dnsEndpoint := &externaldns.DNSEndpoint{}
	want := []*externaldns.Endpoint{
		{
			DNSName:    "localtargets-roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"}},
		{
			DNSName:    "roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"},
			Labels:     externaldns.Labels{"strategy": "roundRobin"}},
	}
	ingressIPs := []corev1.LoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
		{IP: "10.0.0.3"},
	}
	settings := provideSettings(t, predefinedConfig)
	err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
	require.NoError(t, err, "Failed to get expected ingress")
	settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
	err = settings.client.Status().Update(context.TODO(), settings.ingress)
	require.NoError(t, err, "Failed to update gslb Ingress Address")
	createHealthyService(t, &settings, serviceName)
	defer deleteHealthyService(t, &settings, serviceName)
	reconcileAndUpdateGslb(t, settings)

	// act
	err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
	require.NoError(t, err, "Failed to load DNS endpoint")
	got := dnsEndpoint.Spec.Endpoints
	prettyGot := str.ToString(got)
	prettyWant := str.ToString(want)

	// assert
	assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
}

func TestDNSRecordReflectionInStatus(t *testing.T) {
	// arrange
	serviceName := defaultPodinfoServiceName
	dnsEndpoint := &externaldns.DNSEndpoint{}
	want := map[string][]string{"roundrobin.cloud.example.com": {"10.0.0.1", "10.0.0.2", "10.0.0.3"}}
	ingressIPs := []corev1.LoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
		{IP: "10.0.0.3"},
	}
	settings := provideSettings(t, predefinedConfig)
	err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
	require.NoError(t, err, "Failed to get expected ingress")
	settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
	err = settings.client.Status().Update(context.TODO(), settings.ingress)
	require.NoError(t, err, "Failed to update gslb Ingress Address")

	// act
	createHealthyService(t, &settings, serviceName)
	defer deleteHealthyService(t, &settings, serviceName)
	reconcileAndUpdateGslb(t, settings)
	err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
	require.NoError(t, err, "Failed to load DNS endpoint")
	got := settings.gslb.Status.HealthyRecords

	// assert
	assert.Equal(t, got, want, "got:\n %s healthyRecordsMetric status,\n\n want:\n %s", got, want)
}

func TestLocalDNSRecordsHasSpecialAnnotation(t *testing.T) {
	// arrange
	serviceName := defaultPodinfoServiceName
	dnsEndpoint := &externaldns.DNSEndpoint{}
	want := "local"
	ingressIPs := []corev1.LoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
		{IP: "10.0.0.3"},
	}
	utils.NewFakeDNS(fakeDNSSettings).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 3)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 2)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 1)).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, predefinedConfig)
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")

			// act
			createHealthyService(t, &settings, serviceName)
			// delete DNSEndpoint so we can pretend it wasn't annotated before
			deleteDNSEndpoint(t, &settings)
			createDNSEndpoint(t, &settings)
			defer deleteHealthyService(t, &settings, serviceName)
			defer deleteDNSEndpoint(t, &settings)
			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to load DNS endpoint")
			got := dnsEndpoint.Annotations["k8gb.absa.oss/dnstype"]

			// assert
			assert.Equal(t, want, got, "got:\n %q annotation value,\n\n want:\n %q", got, want)
		}).RequireNoError(t)
}

func TestCanGetExternalTargetsFromK8gbInAnotherLocation(t *testing.T) {
	// arrange
	serviceName := defaultPodinfoServiceName
	want := []*externaldns.Endpoint{
		{
			DNSName:    "localtargets-roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"}},
		{
			DNSName:    "roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3", "10.1.0.1", "10.1.0.2", "10.1.0.3"},
			Labels:     externaldns.Labels{"strategy": "roundRobin"}},
	}
	hrWant := map[string][]string{"roundrobin.cloud.example.com": {"10.0.0.1", "10.0.0.2", "10.0.0.3", "10.1.0.1", "10.1.0.2", "10.1.0.3"}}
	ingressIPs := []corev1.LoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
		{IP: "10.0.0.3"},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	utils.NewFakeDNS(fakeDNSSettings).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 3)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 2)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 1)).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, predefinedConfig)

			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")

			// act
			createHealthyService(t, &settings, serviceName)
			defer deleteHealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to get expected DNSEndpoint")

			got := dnsEndpoint.Spec.Endpoints
			hrGot := settings.gslb.Status.HealthyRecords
			prettyGot := str.ToString(got)
			prettyWant := str.ToString(want)

			// assert
			assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
			assert.Equal(t, hrGot, hrWant, "got:\n %s Gslb Records status,\n\n want:\n %s", hrGot, hrWant)
		}).RequireNoError(t)
}

func TestCanCheckExternalGslbTXTRecordForValidityAndFailIfItIsExpired(t *testing.T) {
	// arrange
	utils.NewFakeDNS(fakeDNSSettings).
		AddTXTRecord("test-gslb-heartbeat-eu.example.com.", oldEdgeTimestamp("10m")).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, predefinedConfig)
			// act
			got := settings.assistant.InspectTXTThreshold("test-gslb-heartbeat-eu.example.com", time.Minute*5)
			want := errors.NewResourceExpired("Split brain TXT record expired the time threshold: (5m0s)")
			// assert
			assert.Equal(t, want, got, "got:\n %s from TXT split brain check,\n\n want error:\n %v", got, want)
		}).RequireNoError(t)
}

func TestCanCheckExternalGslbTXTRecordForValidityAndPAssIfItISNotExpired(t *testing.T) {
	// arrange
	utils.NewFakeDNS(fakeDNSSettings).
		AddTXTRecord("test-gslb-heartbeat-za.example.com.", oldEdgeTimestamp("3m")).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, predefinedConfig)
			// act
			err2 := settings.assistant.InspectTXTThreshold("test-gslb-heartbeat-za.example.com", time.Minute*5)
			// assert
			assert.NoError(t, err2, "got:\n %s from TXT split brain check,\n\n want error:\n %v", err2, nil)
		}).RequireNoError(t)
}

func TestReturnsOwnRecordsUsingFailoverStrategyWhenPrimary(t *testing.T) {
	serviceName := defaultPodinfoServiceName
	want := []*externaldns.Endpoint{
		{
			DNSName:    "localtargets-roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"},
		},
		{
			DNSName:    "roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"},
			Labels:     externaldns.Labels{"strategy": depresolver.FailoverStrategy},
		},
	}
	ingressIPs := []corev1.LoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
		{IP: "10.0.0.3"},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	customConfig := predefinedConfig
	customConfig.ClusterGeoTag = "eu"
	settings := provideSettings(t, customConfig)

	// ingress
	err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
	require.NoError(t, err, "Failed to get expected ingress")
	settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
	err = settings.client.Status().Update(context.TODO(), settings.ingress)
	require.NoError(t, err, "Failed to update gslb Ingress Address")

	// enable failover strategy
	settings.gslb.Spec.Strategy.Type = depresolver.FailoverStrategy
	settings.gslb.Spec.Strategy.PrimaryGeoTag = "eu"
	err = settings.client.Update(context.TODO(), settings.gslb)
	require.NoError(t, err, "Can't update gslb")

	// act
	createHealthyService(t, &settings, serviceName)
	defer deleteHealthyService(t, &settings, serviceName)
	reconcileAndUpdateGslb(t, settings)
	err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
	require.NoError(t, err, "Failed to get expected DNSEndpoint")
	got := dnsEndpoint.Spec.Endpoints
	prettyGot := str.ToString(got)
	prettyWant := str.ToString(want)

	// assert
	assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
}

func TestReturnsExternalRecordsUsingFailoverStrategy(t *testing.T) {
	// arrange
	serviceName := defaultPodinfoServiceName
	want := []*externaldns.Endpoint{
		{
			DNSName:    "localtargets-roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2", "10.0.0.3"},
		},
		{
			DNSName:    "roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.1.0.1", "10.1.0.2", "10.1.0.3"},
			Labels:     externaldns.Labels{"strategy": depresolver.FailoverStrategy},
		},
	}
	ingressIPs := []corev1.LoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
		{IP: "10.0.0.3"},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	customConfig := predefinedConfig
	customConfig.ClusterGeoTag = "za"
	customConfig.EdgeDNSServers = []utils.DNSServer{
		{
			Host: "localhost",
			Port: 7753,
		},
	}
	utils.NewFakeDNS(fakeDNSSettings).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 3)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 2)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 1)).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, customConfig)

			// ingress
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")

			// enable failover strategy
			settings.gslb.Spec.Strategy.Type = depresolver.FailoverStrategy
			settings.gslb.Spec.Strategy.PrimaryGeoTag = "eu"
			err = settings.client.Update(context.TODO(), settings.gslb)
			require.NoError(t, err, "Can't update gslb")

			// act
			createHealthyService(t, &settings, serviceName)
			defer deleteHealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to get expected DNSEndpoint")
			got := dnsEndpoint.Spec.Endpoints
			prettyGot := str.ToString(got)
			prettyWant := str.ToString(want)

			// assert
			assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
		}).RequireNoError(t)
}

func TestReturnsExternalRecordsUsingFailoverStrategyAndFallbackDNSserver(t *testing.T) {
	// arrange
	serviceName := "frontend-podinfo"
	want := []*externaldns.Endpoint{
		{
			DNSName:    "localtargets-roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.0.0.1", "10.0.0.2"},
		},
		{
			DNSName:    "roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{"10.1.0.1", "10.1.0.2"},
			Labels:     externaldns.Labels{"strategy": depresolver.FailoverStrategy},
		},
	}
	ingressIPs := []corev1.LoadBalancerIngress{
		{IP: "10.0.0.1"},
		{IP: "10.0.0.2"},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	customConfig := predefinedConfig
	customConfig.ClusterGeoTag = "za"
	customConfig.EdgeDNSServers = []utils.DNSServer{
		{ // this one will be tried frist, but fails
			Host: "localhost",
			Port: 7752,
		},
		{
			Host: "localhost",
			Port: 7753,
		},
		{ // this one fails as well, but shouldn't be tried because the previous works
			Host: "localhost",
			Port: 7754,
		},
	}
	utils.NewFakeDNS(fakeDNSSettings).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 2)).
		AddARecord("localtargets-roundrobin.cloud.example.com.", net.IPv4(10, 1, 0, 1)).
		Start().
		RunTestFunc(func() {
			settings := provideSettings(t, customConfig)

			// ingress
			err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
			require.NoError(t, err, "Failed to get expected ingress")
			settings.ingress.Status.LoadBalancer.Ingress = append(settings.ingress.Status.LoadBalancer.Ingress, ingressIPs...)
			err = settings.client.Status().Update(context.TODO(), settings.ingress)
			require.NoError(t, err, "Failed to update gslb Ingress Address")

			// enable failover strategy
			settings.gslb.Spec.Strategy.Type = depresolver.FailoverStrategy
			settings.gslb.Spec.Strategy.PrimaryGeoTag = "eu"
			err = settings.client.Update(context.TODO(), settings.gslb)
			require.NoError(t, err, "Can't update gslb")

			// act
			createHealthyService(t, &settings, serviceName)
			defer deleteHealthyService(t, &settings, serviceName)
			reconcileAndUpdateGslb(t, settings)
			err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
			require.NoError(t, err, "Failed to get expected DNSEndpoint")
			got := dnsEndpoint.Spec.Endpoints
			prettyGot := str.ToString(got)
			prettyWant := str.ToString(want)

			// assert
			assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
		}).RequireNoError(t)
}

func TestGslbProperlyPropagatesAnnotationDownToIngress(t *testing.T) {
	// arrange
	expectedAnnotations := map[string]string{"annotation": "test", "k8gb.io/strategy": "roundRobin"}
	settings := provideSettings(t, predefinedConfig)
	settings.gslb.Annotations = map[string]string{"annotation": "test"}
	err := settings.client.Update(context.TODO(), settings.gslb)
	require.NoError(t, err, "Can't update gslb")
	// act
	reconcileAndUpdateGslb(t, settings)
	err2 := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
	// assert
	assert.NoError(t, err2, "Failed to get expected ingress")
	assert.Equal(t, expectedAnnotations, settings.ingress.Annotations)
	assert.Equal(t, expectedAnnotations, settings.gslb.ObjectMeta.Annotations)
}

func TestReflectGeoTagInStatusAsUnsetByDefault(t *testing.T) {
	// arrange
	want := "us-west-1"
	settings := provideSettings(t, predefinedConfig)
	// act
	reconcileAndUpdateGslb(t, settings)
	got := settings.gslb.Status.GeoTag
	// assert
	assert.Equal(t, want, got, "got: '%s' GeoTag status, want:'%s'", got, want)
}

func TestReflectGeoTagInTheStatus(t *testing.T) {
	// arrange
	want := "eu"
	customConfig := predefinedConfig
	customConfig.ClusterGeoTag = "eu"
	settings := provideSettings(t, customConfig)
	// act
	reconcileAndUpdateGslb(t, settings)
	got := settings.gslb.Status.GeoTag
	// assert
	assert.Equal(t, want, got, "got: '%s' GeoTag status, want:'%s'", got, want)
}

func TestDetectsIngressHostnameMismatch(t *testing.T) {
	// arrange
	// getting Gslb and Reconciler
	predefinedSettings := provideSettings(t, predefinedConfig)
	customConfig := predefinedConfig
	customConfig.EdgeDNSZone = "otherdnszone.com"
	predefinedSettings.config = customConfig
	req := reconcile.Request{
		NamespacedName: types.NamespacedName{
			Name:      predefinedSettings.gslb.Name,
			Namespace: predefinedSettings.gslb.Namespace,
		},
	}
	// injecting custom config to reconciler created from predefined config
	predefinedSettings.reconciler.Config = &customConfig
	// act
	_, err := predefinedSettings.reconciler.Reconcile(context.TODO(), req)
	// assert
	assert.Error(t, err, "expected controller to detect Ingress hostname and edgeDNSZone mismatch")
	assert.True(t, strings.HasSuffix(err.Error(), "cloud.example.com does not match delegated zone otherdnszone.com"))
}

func TestCreatesDNSNSRecordsForExtDNS(t *testing.T) {
	// arrange
	const dnsZone = "cloud.example.com"
	const want = "extdns"
	wantEp := []*externaldns.Endpoint{
		{
			DNSName:    dnsZone,
			RecordTTL:  30,
			RecordType: "NS",
			Targets: externaldns.Targets{
				"gslb-ns-eu-cloud.example.com",
				"gslb-ns-us-cloud.example.com",
				"gslb-ns-za-cloud.example.com",
			},
		},
		{
			DNSName:    "gslb-ns-eu-cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets: externaldns.Targets{
				defaultEdgeDNS0,
				defaultEdgeDNS1,
			},
		},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	customConfig := predefinedConfig
	customConfig.EdgeDNSServers = defaultEdgeDNSServers
	customConfig.CoreDNSExposed = true
	coreDNSService := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      defaultCoreDNSExtServiceName,
			Namespace: predefinedConfig.K8gbNamespace,
			Labels: map[string]string{
				"app.kubernetes.io/name": "coredns",
			},
		},
	}
	serviceIPs := []corev1.LoadBalancerIngress{
		{Hostname: "one.one.one.one"}, // rely on 1.1.1.1 response from Cloudflare
	}
	settings := provideSettings(t, customConfig)
	err := settings.client.Create(context.TODO(), coreDNSService)
	require.NoError(t, err, "Failed to create testing %s service", defaultCoreDNSExtServiceName)
	coreDNSService.Status.LoadBalancer.Ingress = append(coreDNSService.Status.LoadBalancer.Ingress, serviceIPs...)
	err = settings.client.Status().Update(context.TODO(), coreDNSService)
	require.NoError(t, err, "Failed to update coredns service lb hostname")

	// act
	customConfig.EdgeDNSType = depresolver.DNSTypeExternal
	customConfig.ClusterGeoTag = "eu"
	customConfig.ExtClustersGeoTags = []string{"za", "us"}
	customConfig.DNSZone = dnsZone
	// apply new environment variables and update config only
	settings.reconciler.Config = &customConfig
	// If config is changed, new Route53 provider needs to be re-created. There is no way and reason to change provider
	// configuration at another time than startup
	f, _ := dns.NewDNSProviderFactory(settings.reconciler.Client, customConfig)
	settings.reconciler.DNSProvider = f.Provider()

	reconcileAndUpdateGslb(t, settings)
	err = settings.client.Get(context.TODO(), client.ObjectKey{Namespace: predefinedConfig.K8gbNamespace, Name: "k8gb-ns-extdns"}, dnsEndpoint)
	require.NoError(t, err, "Failed to get expected DNSEndpoint")
	got := dnsEndpoint.Annotations["k8gb.absa.oss/dnstype"]
	gotEp := dnsEndpoint.Spec.Endpoints
	prettyGot := str.ToString(gotEp)
	prettyWant := str.ToString(wantEp)

	// assert
	assert.Equal(t, want, got, "got:\n %q annotation value,\n\n want:\n %q", got, want)
	assert.Equal(t, wantEp, gotEp, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
}

func TestCreatesDNSNSRecordsForLoadBalancer(t *testing.T) {
	// arrange
	const dnsZone = "cloud.example.com"
	const want = "extdns"
	wantEp := []*externaldns.Endpoint{
		{
			DNSName:    dnsZone,
			RecordTTL:  30,
			RecordType: "NS",
			Targets: externaldns.Targets{
				"gslb-ns-eu-cloud.example.com",
				"gslb-ns-us-cloud.example.com",
				"gslb-ns-za-cloud.example.com",
			},
		},
		{
			DNSName:    "gslb-ns-eu-cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets: externaldns.Targets{
				defaultEdgeDNS1,
			},
		},
	}
	dnsEndpoint := &externaldns.DNSEndpoint{}
	customConfig := predefinedConfig
	customConfig.EdgeDNSServers = defaultEdgeDNSServers
	customConfig.CoreDNSExposed = true
	coreDNSService := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      defaultCoreDNSExtServiceName,
			Namespace: predefinedConfig.K8gbNamespace,
			Labels: map[string]string{
				"app.kubernetes.io/name": "coredns",
			},
		},
	}
	serviceIPs := []corev1.LoadBalancerIngress{
		{IP: "1.1.1.1"},
	}
	settings := provideSettings(t, customConfig)
	err := settings.client.Create(context.TODO(), coreDNSService)
	require.NoError(t, err, "Failed to create testing %s service", defaultCoreDNSExtServiceName)
	coreDNSService.Status.LoadBalancer.Ingress = append(coreDNSService.Status.LoadBalancer.Ingress, serviceIPs...)
	err = settings.client.Status().Update(context.TODO(), coreDNSService)
	require.NoError(t, err, "Failed to update coredns service lb hostname")

	// act
	customConfig.EdgeDNSType = depresolver.DNSTypeExternal
	customConfig.ClusterGeoTag = "eu"
	customConfig.ExtClustersGeoTags = []string{"za", "us"}
	customConfig.DNSZone = dnsZone
	// apply new environment variables and update config only
	settings.reconciler.Config = &customConfig
	// If config is changed, new Route53 provider needs to be re-created. There is no way and reason to change provider
	// configuration at another time than startup
	f, _ := dns.NewDNSProviderFactory(settings.reconciler.Client, customConfig)
	settings.reconciler.DNSProvider = f.Provider()

	reconcileAndUpdateGslb(t, settings)
	err = settings.client.Get(context.TODO(), client.ObjectKey{Namespace: predefinedConfig.K8gbNamespace, Name: "k8gb-ns-extdns"}, dnsEndpoint)
	require.NoError(t, err, "Failed to get expected DNSEndpoint")
	got := dnsEndpoint.Annotations["k8gb.absa.oss/dnstype"]
	gotEp := dnsEndpoint.Spec.Endpoints
	prettyGot := str.ToString(gotEp)
	prettyWant := str.ToString(wantEp)

	// assert
	assert.Equal(t, want, got, "got:\n %q annotation value,\n\n want:\n %q", got, want)
	assert.Equal(t, wantEp, gotEp, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
}

func TestResolvesLoadBalancerHostnameFromIngressStatus(t *testing.T) {
	// arrange
	customConfig := predefinedConfig
	serviceName := defaultPodinfoServiceName
	customConfig.EdgeDNSServers = defaultEdgeDNSServers
	want := []*externaldns.Endpoint{
		{
			DNSName:    "localtargets-roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{defaultEdgeDNS0, defaultEdgeDNS1}},
		{
			DNSName:    "roundrobin.cloud.example.com",
			RecordTTL:  30,
			RecordType: "A",
			Targets:    externaldns.Targets{defaultEdgeDNS0, defaultEdgeDNS1},
			Labels:     externaldns.Labels{"strategy": "roundRobin"}},
	}
	settings := provideSettings(t, customConfig)
	dnsEndpoint := &externaldns.DNSEndpoint{ObjectMeta: metav1.ObjectMeta{Namespace: settings.gslb.Namespace, Name: settings.gslb.Name}}
	createHealthyService(t, &settings, serviceName)
	defer deleteHealthyService(t, &settings, serviceName)
	err := settings.client.Get(context.TODO(), settings.request.NamespacedName, settings.ingress)
	require.NoError(t, err, "Failed to get expected ingress")

	settings.ingress.Status.LoadBalancer.Ingress = []corev1.LoadBalancerIngress{{Hostname: "one.one.one.one"}}
	err = settings.client.Status().Update(context.TODO(), settings.ingress)
	require.NoError(t, err, "Failed to update gslb Ingress Address")

	// act
	err = settings.client.Delete(context.Background(), dnsEndpoint)
	require.NoError(t, err, "Failed to update DNSEndpoint")
	reconcileAndUpdateGslb(t, settings)
	err = settings.client.Get(context.TODO(), settings.request.NamespacedName, dnsEndpoint)
	require.NoError(t, err, "Failed to get expected DNSEndpoint")
	got := dnsEndpoint.Spec.Endpoints
	prettyGot := str.ToString(got)
	prettyWant := str.ToString(want)

	// assert
	assert.Equal(t, want, got, "got:\n %s DNSEndpoint,\n\n want:\n %s", prettyGot, prettyWant)
}

func TestRoute53ZoneDelegationGarbageCollection(t *testing.T) {
	// arrange
	customConfig := predefinedConfig
	settings := provideSettings(t, customConfig)
	coreDNSService := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      defaultCoreDNSExtServiceName,
			Namespace: predefinedConfig.K8gbNamespace,
		},
	}
	serviceIPs := []corev1.LoadBalancerIngress{
		{Hostname: "one.one.one.one"}, // rely on 1.1.1.1 response from Cloudflare
	}
	err := settings.client.Create(context.TODO(), coreDNSService)
	require.NoError(t, err, "Failed to create testing %s service", defaultCoreDNSExtServiceName)
	coreDNSService.Status.LoadBalancer.Ingress = append(coreDNSService.Status.LoadBalancer.Ingress, serviceIPs...)
	err = settings.client.Status().Update(context.TODO(), coreDNSService)
	require.NoError(t, err, "Failed to update coredns service lb hostname")

	// act
	customConfig.EdgeDNSType = depresolver.DNSTypeExternal
	// apply new environment variables and update config only
	settings.reconciler.Config = &customConfig
	reconcileAndUpdateGslb(t, settings)

	deletionTimestamp := metav1.Now()
	settings.gslb.SetDeletionTimestamp(&deletionTimestamp)
	err = settings.client.Update(context.Background(), settings.gslb)
	require.NoError(t, err, "Failed to update Gslb")
	settings.finalCall = true // Gslb is about to be deleted, no requeue expected
	reconcileAndUpdateGslb(t, settings)

	// assert
	dnsEndpointRoute53 := &externaldns.DNSEndpoint{}
	err = settings.client.Get(context.TODO(), client.ObjectKey{Namespace: predefinedConfig.K8gbNamespace, Name: "k8gb-ns-route53"}, dnsEndpointRoute53)
	require.Error(t, err, "k8gb-ns-route53 DNSEndpoint should be garbage collected")
}

func TestGslbSetsAnnotationsOnTheIngress(t *testing.T) {
	// arrange
	settings := provideSettings(t, predefinedConfig)

	// act
	reconcileAndUpdateGslb(t, settings)

	// assert
	ingress := &netv1.Ingress{}
	err := settings.client.Get(context.Background(), client.ObjectKey{Namespace: settings.gslb.Namespace, Name: settings.gslb.Name}, ingress)
	require.NoError(t, err, "Gslb should be created from annotated Ingress")

	assert.Equal(t, map[string]string{strategyAnnotation: "roundRobin"}, ingress.Annotations)
}

func TestGslbGetFinalizer(t *testing.T) {
	// arrange
	gslb := &k8gbv1beta1.Gslb{}
	settings := provideSettings(t, predefinedConfig)

	// act
	reconcileAndUpdateGslb(t, settings)

	// assert
	err := settings.reconciler.Get(context.TODO(), settings.request.NamespacedName, gslb)
	require.NoError(t, err)
	assert.Len(t, gslb.Finalizers, 1)
}

func TestGslbRemoveDefaultFinalizer(t *testing.T) {
	// arrange
	gslb := &k8gbv1beta1.Gslb{}
	var dt = metav1.Now()
	settings := provideSettings(t, predefinedConfig)
	settings.gslb.SetDeletionTimestamp(&dt)
	err := settings.reconciler.Update(context.Background(), settings.gslb)
	require.NoError(t, err, "Failed to update Gslb")
	settings.finalCall = true // Gslb is about to be deleted, no requeue expected

	// act
	reconcileAndUpdateGslb(t, settings)

	// assert
	err = settings.client.Get(context.TODO(), settings.request.NamespacedName, gslb)
	require.EqualError(t, err, "gslbs.k8gb.absa.oss \"test-gslb\" not found")
	assert.Len(t, gslb.Finalizers, 0)
}

func TestGslbRemoveBothFinalizers(t *testing.T) {
	// arrange
	gslb := &k8gbv1beta1.Gslb{}
	var dt = metav1.Now()
	settings := provideSettings(t, predefinedConfig)
	settings.gslb.SetDeletionTimestamp(&dt)
	settings.gslb.Finalizers = append(settings.gslb.Finalizers, "finalizer.k8gb.absa.oss")
	err := settings.client.Update(context.Background(), settings.gslb)
	require.NoError(t, err, "Failed to update Gslb")
	settings.finalCall = true // Gslb is about to be deleted, no requeue expected

	// act
	reconcileAndUpdateGslb(t, settings)

	// assert
	err = settings.reconciler.Get(context.TODO(), settings.request.NamespacedName, gslb)
	require.EqualError(t, err, "gslbs.k8gb.absa.oss \"test-gslb\" not found")
	assert.Len(t, gslb.Finalizers, 0)
}

func createHealthyService(t *testing.T, s *testSettings, serviceName string) {
	t.Helper()
	service := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}
	err := s.client.Create(context.TODO(), service)
	if err != nil {
		t.Fatalf("Failed to create testing service: (%v)", err)
	}

	// Create fake endpoint with populated address slice
	endpoint := &corev1.Endpoints{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
		Subsets: []corev1.EndpointSubset{
			{
				Addresses: []corev1.EndpointAddress{{IP: "1.2.3.4"}},
			},
		},
	}

	err = s.client.Create(context.TODO(), endpoint)
	if err != nil {
		t.Fatalf("Failed to create testing endpoint: (%v)", err)
	}
}

func deleteHealthyService(t *testing.T, s *testSettings, serviceName string) {
	t.Helper()
	service := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}
	err := s.client.Delete(context.TODO(), service)
	if err != nil {
		t.Fatalf("Failed to delete testing service: (%v)", err)
	}

	// Create fake endpoint with populated address slice
	endpoint := &corev1.Endpoints{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
		Subsets: []corev1.EndpointSubset{
			{
				Addresses: []corev1.EndpointAddress{{IP: "1.2.3.4"}},
			},
		},
	}

	err = s.client.Delete(context.TODO(), endpoint)
	if err != nil {
		t.Fatalf("Failed to delete testing endpoint: (%v)", err)
	}
}

func createUnhealthyService(t *testing.T, s *testSettings, serviceName string) {
	t.Helper()
	service := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}

	err := s.client.Create(context.TODO(), service)
	if err != nil {
		t.Fatalf("Failed to create testing service: (%v)", err)
	}

	endpoint := &corev1.Endpoints{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}

	err = s.client.Create(context.TODO(), endpoint)
	if err != nil {
		t.Fatalf("Failed to create testing endpoint: (%v)", err)
	}
}

func deleteUnhealthyService(t *testing.T, s *testSettings, serviceName string) {
	t.Helper()
	service := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}

	err := s.client.Delete(context.TODO(), service)
	if err != nil {
		t.Fatalf("Failed to delete testing service: (%v)", err)
	}

	endpoint := &corev1.Endpoints{
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceName,
			Namespace: s.gslb.Namespace,
		},
	}

	err = s.client.Delete(context.TODO(), endpoint)
	if err != nil {
		t.Fatalf("Failed to delete testing endpoint: (%v)", err)
	}

}
func createDNSEndpoint(t *testing.T, s *testSettings) {
	t.Helper()
	dnsEndpoint := &externaldns.DNSEndpoint{
		ObjectMeta: metav1.ObjectMeta{
			Name:      s.gslb.Name,
			Namespace: s.gslb.Namespace,
		},
	}
	err := s.client.Create(context.TODO(), dnsEndpoint)
	if err != nil {
		t.Fatalf("Failed to create testing DNSEndpoint: (%v)", err)
	}
}

func deleteDNSEndpoint(t *testing.T, s *testSettings) {
	t.Helper()
	endpoint := &externaldns.DNSEndpoint{
		ObjectMeta: metav1.ObjectMeta{
			Name:      s.gslb.Name,
			Namespace: s.gslb.Namespace,
		},
	}
	err := s.client.Delete(context.TODO(), endpoint)
	if err != nil {
		t.Fatalf("Failed to delete testing DNSEndpoint: (%v)", err)
	}
}

func reconcileAndUpdateGslb(t *testing.T, s testSettings) {
	t.Helper()
	// Reconcile again so Reconcile() checks services and updates the Gslb
	// resources' Status.
	res, err := s.reconciler.Reconcile(context.TODO(), s.request)
	if err != nil {
		return
	}

	if !s.finalCall {
		if res != (reconcile.Result{RequeueAfter: time.Second * 30}) {
			t.Error("reconcile did not return Result with Requeue")
		}
		err = s.reconciler.Get(context.TODO(), s.request.NamespacedName, s.gslb)
		if err != nil {
			t.Fatalf("Failed to get expected gslb: (%v)", err)
		}
	}

}

func provideSettings(t *testing.T, expected depresolver.Config) (settings testSettings) {
	_, err := os.Stat(crSampleYaml)
	if os.IsNotExist(err) {
		t.Fatalf("Sample CR yaml file not found at: %s", crSampleYaml)
	}
	gslbYaml, err := ioutil.ReadFile(crSampleYaml)
	if err != nil {
		t.Fatalf("Can't open example CR file: %s", crSampleYaml)
	}
	// Set the log to development mode for verbose logs.
	gslb, err := utils.YamlToGslb(gslbYaml)
	if err != nil {
		t.Fatal(err)
	}
	objs := []runtime.Object{
		gslb,
	}
	// Register operator types with the runtime scheme.
	s := scheme.Scheme
	s.AddKnownTypes(k8gbv1beta1.GroupVersion, gslb)
	// Register external-dns DNSEndpoint CRD
	s.AddKnownTypes(schema.GroupVersion{Group: "externaldns.k8s.io", Version: "v1alpha1"}, &externaldns.DNSEndpoint{})
	// Create a fake client to mock API calls.
	cl := fake.NewClientBuilder().WithScheme(s).WithRuntimeObjects(objs...).Build()
	// Create a GslbReconciler object with the scheme and fake client.
	r := &GslbReconciler{
		Client: cl,
		Scheme: s,
	}
	r.DepResolver = depresolver.NewDependencyResolver()
	r.Config = &expected
	// Mock request to simulate Reconcile() being called on an event for a
	// watched resource .
	req := reconcile.Request{
		NamespacedName: types.NamespacedName{
			Name:      gslb.Name,
			Namespace: gslb.Namespace,
		},
	}

	var f *dns.ProviderFactory
	f, err = dns.NewDNSProviderFactory(r.Client, *r.Config)
	if err != nil {
		t.Fatalf("reconcile: (%v)", err)
	}
	r.DNSProvider = f.Provider()
	a := assistant.NewGslbAssistant(r.Client, r.Config.K8gbNamespace, r.Config.EdgeDNSServers)
	res, err := r.Reconcile(context.TODO(), req)
	if err != nil {
		t.Fatalf("reconcile: (%v)", err)
	}

	if res.Requeue {
		t.Error("requeue expected")
	}
	ingress := &netv1.Ingress{}
	err = cl.Get(context.TODO(), req.NamespacedName, ingress)
	if err != nil {
		t.Fatalf("Failed to get expected ingress: (%v)", err)
	}

	// Reconcile again so Reconcile() checks services and updates the Gslb
	// resources' Status.
	settings = testSettings{
		gslb:       gslb,
		config:     expected,
		reconciler: r,
		request:    req,
		client:     cl,
		ingress:    ingress,
		finalCall:  false,
		assistant:  a,
	}
	reconcileAndUpdateGslb(t, settings)
	return settings
}

func oldEdgeTimestamp(threshold string) string {
	now := time.Now()
	duration, _ := time.ParseDuration(threshold)
	before := now.Add(-duration)
	edgeTimestamp := fmt.Sprint(before.UTC().Format("2006-01-02T15:04:05"))
	return edgeTimestamp
}

func TestMain(m *testing.M) {
	var exitCode int
	defer func() {
		metrics.Metrics().Unregister()
		os.Exit(exitCode)
	}()
	logging.Init(&predefinedConfig)
	metrics.Init(&predefinedConfig)
	err := metrics.Metrics().Register()
	if err != nil {
		logging.Logger().Fatal().Err(err).Msg("metrics register")
	}
	exitCode = m.Run()
}
